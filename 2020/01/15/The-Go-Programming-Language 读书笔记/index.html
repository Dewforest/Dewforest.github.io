<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>The-Go-Programming-Language 读书笔记 | Amezf's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">The-Go-Programming-Language 读书笔记</h1><a id="logo" href="/.">Amezf's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 文章</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">The-Go-Programming-Language 读书笔记</h1><div class="post-meta">Jan 15, 2020<span> | </span><span class="category"><a href="/categories/Golang/">Golang</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#程序结构"><span class="toc-number">1.</span> <span class="toc-text">程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#命名"><span class="toc-number">1.1.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#声明"><span class="toc-number">1.2.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-number">1.3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简短变量声明"><span class="toc-number">1.3.1.</span> <span class="toc-text">简短变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针"><span class="toc-number">1.3.2.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-函数"><span class="toc-number">1.3.3.</span> <span class="toc-text">new 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#赋值"><span class="toc-number">1.4.</span> <span class="toc-text">赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#元组赋值"><span class="toc-number">1.4.1.</span> <span class="toc-text">元组赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可赋值性"><span class="toc-number">1.4.2.</span> <span class="toc-text">可赋值性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型"><span class="toc-number">1.5.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包与文件"><span class="toc-number">1.6.</span> <span class="toc-text">包与文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础数据类型"><span class="toc-number">2.</span> <span class="toc-text">基础数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#整型"><span class="toc-number">2.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浮点数"><span class="toc-number">2.2.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复数"><span class="toc-number">2.3.</span> <span class="toc-text">复数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">2.4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串和-Byte-切片"><span class="toc-number">2.4.1.</span> <span class="toc-text">字符串和 Byte 切片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量"><span class="toc-number">2.5.</span> <span class="toc-text">常量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合数据类型"><span class="toc-number">3.</span> <span class="toc-text">复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">3.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slice"><span class="toc-number">3.2.</span> <span class="toc-text">Slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#append-函数"><span class="toc-number">3.2.1.</span> <span class="toc-text">append() 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">3.3.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体"><span class="toc-number">3.4.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体字面值"><span class="toc-number">3.4.1.</span> <span class="toc-text">结构体字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体比较"><span class="toc-number">3.4.2.</span> <span class="toc-text">结构体比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体嵌入和匿名成员"><span class="toc-number">3.4.3.</span> <span class="toc-text">结构体嵌入和匿名成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON"><span class="toc-number">3.5.</span> <span class="toc-text">JSON</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文本和-HTML-模板"><span class="toc-number">3.6.</span> <span class="toc-text">文本和 HTML 模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数声明"><span class="toc-number">4.1.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误"><span class="toc-number">4.2.</span> <span class="toc-text">错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理策略"><span class="toc-number">4.2.1.</span> <span class="toc-text">错误处理策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数值"><span class="toc-number">4.3.</span> <span class="toc-text">函数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名函数"><span class="toc-number">4.4.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可变参数"><span class="toc-number">4.5.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deferred-函数"><span class="toc-number">4.6.</span> <span class="toc-text">Deferred 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法"><span class="toc-number">5.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基于指针对象的方法"><span class="toc-number">5.1.</span> <span class="toc-text">基于指针对象的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过嵌入结构体来扩展类型"><span class="toc-number">5.2.</span> <span class="toc-text">通过嵌入结构体来扩展类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法值和方法表达式"><span class="toc-number">5.3.</span> <span class="toc-text">方法值和方法表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-练习"><span class="toc-number">5.3.1.</span> <span class="toc-text">6.5 练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#封装"><span class="toc-number">5.4.</span> <span class="toc-text">封装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接口"><span class="toc-number">6.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口约定"><span class="toc-number">6.1.</span> <span class="toc-text">接口约定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#练习7-1"><span class="toc-number">6.1.1.</span> <span class="toc-text">练习7.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习7-2"><span class="toc-number">6.1.2.</span> <span class="toc-text">练习7.2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口类型"><span class="toc-number">6.2.</span> <span class="toc-text">接口类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#练习7-4-7-5"><span class="toc-number">6.2.1.</span> <span class="toc-text">练习7.4 7.5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现接口的条件"><span class="toc-number">6.3.</span> <span class="toc-text">实现接口的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sort-interface-接口"><span class="toc-number">6.4.</span> <span class="toc-text">sort.interface 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#error-接口"><span class="toc-number">6.5.</span> <span class="toc-text">error 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型断言"><span class="toc-number">6.6.</span> <span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于类型断言区别错误类型"><span class="toc-number">6.7.</span> <span class="toc-text">基于类型断言区别错误类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型开关"><span class="toc-number">6.8.</span> <span class="toc-text">类型开关</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Goroutines-和-Channels"><span class="toc-number">7.</span> <span class="toc-text">Goroutines 和 Channels</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Goroutines"><span class="toc-number">7.1.</span> <span class="toc-text">Goroutines</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channels"><span class="toc-number">7.2.</span> <span class="toc-text">Channels</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#串联的-channels"><span class="toc-number">7.2.1.</span> <span class="toc-text">串联的 channels</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单方向的-Channel"><span class="toc-number">7.2.2.</span> <span class="toc-text">单方向的 Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带缓存的-Channels"><span class="toc-number">7.2.3.</span> <span class="toc-text">带缓存的 Channels</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>中文译名：《Go 语言圣经》</p>
<p>”Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.“</p>
<a id="more"></a>

<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>在习惯上，Go 语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。因此，在标准库有 QuoteRuneToASCII 和 parseRequestLine 这样的函数命名，但是一般不会用 quote_rune_to_ASCII 和 parse_request_line 这样的命名。而像 ASCII 和 HTML 这样的缩略词则避免使用大小写混合的写法，它们可能被称为 htmlEscape、HTMLEscape 或 escapeHTML，但不会是 escapeHtml</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>Go 语言主要有四种类型的声明语句：var、const、type 和 func</p>
<p>分别对应变量、常量、类型和函数实体对象的声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boilingF = <span class="number">212.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f = boilingF</span><br><span class="line">	<span class="keyword">var</span> c = (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></span><br><span class="line">	fmt.Printf(<span class="string">"boiling point = %g°F or %g°c\n"</span>, f, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var 声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure>

<p>其中 “<em>类型</em>” 或 “ <em>= 表达式</em>” 两个部分可以省略其中的一个。</p>
<p>如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息</p>
<p>如果初始化表达式被省略，那么将用零值初始化该变量</p>
<p><strong>数值</strong>类型变量对应的零值是 <strong>0</strong></p>
<p><strong>布尔</strong>类型变量对应的零值是 <strong>false</strong></p>
<p><strong>字符串</strong>类型对应的零值是<strong>空字符串</strong></p>
<p><strong>接口或引用</strong>类型（包括 slice、指针、map、chan 和函数）变量对应的零值是 <strong>nil</strong></p>
<p><strong>数组</strong>或<strong>结构体</strong>等聚合类型对应的零值是每个元素或字段都是<strong>对应该类型的零值</strong></p>
<h3 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a>简短变量声明</h3><p>以 <code>名字 := 表达式</code>的形式声明变量，变量的类型根据表达式来自动推导，下面是<code>lissajous</code>函数中的三个简短变量声明语句</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anim := gif.GIF&#123;loopCount: nframes&#125;</span><br><span class="line">freq := rand.Float64() * <span class="number">3.0</span></span><br><span class="line">t := <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p>因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化</p>
<p>var 形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> boiling <span class="keyword">float64</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> names []String</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> p Point</span><br></pre></td></tr></table></figure>

<p>如果有一些已经在相同的词法域声明过了</p>
<p>那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">out, err := os.Create(outfile)</span><br></pre></td></tr></table></figure>

<p>简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f, err := os.Create(outfile) <span class="comment">// compile error: no new variables</span></span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>与C语言指针类似</p>
<p>一个指针的值是另一个变量的地址，一个指针对应变量在内存中的存储位置，并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址</p>
<p>通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x         <span class="comment">// p, of type *int, points to x</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "1"</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// equivalent to x = 2</span></span><br><span class="line">fmt.Println(x)  <span class="comment">// "2"</span></span><br></pre></td></tr></table></figure>

<h3 id="new-函数"><a href="#new-函数" class="headerlink" title="new 函数"></a>new 函数</h3><p>另一个创建变量的方法是调用内建的 new 函数</p>
<p>表达式 new (T) 将创建一个 T 类型的匿名变量，初始化为 T 类型的零值，然后返回变量地址，返回的指针类型为 <code>*T</code></p>
<p><strong>相当于创建了一个只知道地址，却没有名字的临时变量，用指针去读取该值</strong></p>
<p>用 new 创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用 new (T)</p>
<p>换言之，new 函数类似是一种语法糖，而不是一个新的基础概念</p>
<p>每次调用 new 函数都是返回一个新的变量的地址，因此下面两个地址是不同的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">q := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(p == q) <span class="comment">// "false"</span></span><br></pre></td></tr></table></figure>

<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>二元算术运算符和赋值语句的复合操作有一个简洁形式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count[x] *= scale</span><br></pre></td></tr></table></figure>

<h3 id="元组赋值"><a href="#元组赋值" class="headerlink" title="元组赋值"></a>元组赋值</h3><p>元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值</p>
<p>在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x</span><br><span class="line"></span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br></pre></td></tr></table></figure>

<p>GCD算法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h3><p>函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medals := []<span class="keyword">string</span>&#123;<span class="string">"gold"</span>, <span class="string">"silver"</span>, <span class="string">"bronze"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这与下面赋值行为类似</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">medals[<span class="number">0</span>] = <span class="string">"gold"</span></span><br><span class="line">medals[<span class="number">1</span>] = <span class="string">"silver"</span></span><br><span class="line">medals[<span class="number">2</span>] = <span class="string">"bronze"</span></span><br></pre></td></tr></table></figure>

<p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的</p>
<p>可赋值性的规则对于不同类型有着不同要求</p>
<p>对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil 可以赋值给任何指针或引用类型的变量</p>
<p>常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构</p>
<p>新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容</p>
<p><code>type 类型名字 底层类型</code></p>
<p>将<code>float64</code>类型定义为两种不同的温度单位类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	AbsoluteZeroC Celsius = <span class="number">-273.15</span></span><br><span class="line">	FreezingC Celsius = <span class="number">0</span></span><br><span class="line">	BoilingC Celsius = <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span> <span class="title">Fahrenheit</span></span> &#123; <span class="keyword">return</span> Fahrenheit(c * <span class="number">9</span> / <span class="number">5</span> + <span class="number">32</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span> <span class="title">Celsius</span></span> &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>)&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于每一个类型T，都有一个对应的类型转换操作<code>T(x)</code>，用于将x转换为T类型，只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身</strong></p>
<p>比较运算符 <code>==</code> 和 <code>&lt;</code> 也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较</p>
<p>但是如果两个值有着不同的类型，则不能直接进行比较</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c Celsius</span><br><span class="line"><span class="keyword">var</span> f Fahrenheit</span><br><span class="line">fmt.Println(c == <span class="number">0</span>)          <span class="comment">// "true"</span></span><br><span class="line">fmt.Println(f &gt;= <span class="number">0</span>)          <span class="comment">// "true"</span></span><br><span class="line">fmt.Println(c == f)          <span class="comment">// compile error: type mismatch</span></span><br><span class="line">fmt.Println(c == Celsius(f)) <span class="comment">// "true"!</span></span><br></pre></td></tr></table></figure>

<h2 id="包与文件"><a href="#包与文件" class="headerlink" title="包与文件"></a>包与文件</h2><p>Go 语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用</p>
<h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整数之间的相互转换并不会改变数值，它们只是告诉编译器如何解释这个值</p>
<p><strong>但是对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度</strong></p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>Go 语言提供了两种精度的浮点数，<code>float32</code> 和 <code>float64</code></p>
<p>在<code>math</code>包里能查找到浮点数的范围极限值，常量<code>math.MaxFloat32</code>表示<code>float32</code>的最大值，3.4e38</p>
<p>常量<code>math.MaxFloat64</code></p>
<hr>
<p><code>math</code>包中还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：</p>
<p>正无穷大和负无穷大，分别用于表示太大溢出的数字和清零的结果</p>
<p>NaN非数，一般用于表示无效的除法操作结果0/0，sqrt(-1)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">float64</span> <span class="comment">//z = 0</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z) <span class="comment">// 0 -0 +inf -inf NaN</span></span><br></pre></td></tr></table></figure>

<p>可以用<code>math.IsNaN</code>用于测试一个数是否是非数NaN，<code>math.NaN</code>则返回非数对应的值</p>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>Go 语言提供了两种精度的复数类型，<code>complex64</code>和<code>complex128</code>，分别对应<code>float32</code>和<code>float64</code>两种浮点数精度</p>
<p>内置的<code>complex</code>函数用于构建复数，内建的<code>real</code>和<code>imag</code>函数分别返回复数的实部和虚部</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Println(x * y)</span><br><span class="line">fmt.Println(<span class="built_in">real</span>(x * y))</span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(x * y))</span><br></pre></td></tr></table></figure>

<p><strong>练习 3.5：</strong> 实现一个彩色的 Mandelbrot 图像，使用 image.NewRGBA 创建图像，使用 color.RGBA 或 color.YCbCr 生成颜色。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> color.Black </span><br><span class="line"><span class="comment">// -&gt; return color.RGBA&#123;255,182,193,255&#125; 猛男粉</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>内置的<code>len</code>函数可以返回一个字符串中的字节数目，索引操作<code>s[i]</code>返回第i个字节的字节值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello, wolrd"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))		<span class="comment">// "12"</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>], s[<span class="number">7</span>])	<span class="comment">// "104 119" ('h' and 'w')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果试图访问超过字符串索引范围的字节将会导致Panic异常</span></span><br><span class="line"></span><br><span class="line">c := s[<span class="built_in">len</span>(s)] <span class="comment">// panic: index out of range</span></span><br></pre></td></tr></table></figure>

<p>子字符串操作 s [i:j] 基于原始的 s 字符串的第 i 个字节开始到第 j 个字节（并不包含 j 本身）生成一个新字符串，生成的新字符串将包含 j-i 个字节</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s[<span class="number">0</span>:<span class="number">5</span>]) <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure>

<p>不管 i 还是 j 都可能被忽略，当它们被忽略时将采用 0 作为开始位置，采用 len (s) 作为结束的位置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s[:<span class="number">5</span>]) <span class="comment">// "hello"</span></span><br><span class="line">fmt.Println(s[<span class="number">7</span>:]) <span class="comment">// "world"</span></span><br><span class="line">fmt.Println(s[:])  <span class="comment">// "hello, world"</span></span><br></pre></td></tr></table></figure>

<p>其中 + 操作符将两个字符串连接构造一个新字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"goodbye"</span> + s[<span class="number">5</span>:]) <span class="comment">// "goodbye, world"</span></span><br></pre></td></tr></table></figure>

<p>字符串可以用 == 和 &lt; 进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序</p>
<p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值</p>
<p>可以像下面这样将一个字符串追加到另一个字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"left foot"</span></span><br><span class="line">t := s</span><br><span class="line">s += <span class="string">", right foot"</span></span><br></pre></td></tr></table></figure>

<p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="string">'L'</span> <span class="comment">// compile error: cannot assign to s[0]</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串和-Byte-切片"><a href="#字符串和-Byte-切片" class="headerlink" title="字符串和 Byte 切片"></a>字符串和 Byte 切片</h3><p><code>bytes</code>包和<code>strings</code>包同时提供了许多实用函数</p>
<p><code>strings</code>包的六个函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p><code>bytes</code>包对应的六个函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(b, subslice []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(s [][]<span class="keyword">byte</span>, sep []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>无类型常量</strong></p>
<p>在Go语言中许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算（至少有 256bit 的运算精度）</p>
<p>这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串</p>
<p><code>math.Pi</code>无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float32</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span> = math.Pi</span><br></pre></td></tr></table></figure>

<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成因为数组的长度是固定的，因此在 Go 语言中很少直接使用数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ar a [<span class="number">3</span>]<span class="keyword">int</span>             <span class="comment">// array of 3 integers</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>])        <span class="comment">// print the first element</span></span><br><span class="line">fmt.Println(a[<span class="built_in">len</span>(a)<span class="number">-1</span>]) <span class="comment">// print the last element, a[2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the indices and elements.</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d %d\n"</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the elements only.</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是 0。我们也可以使用数组字面值语法用一组值来初始化数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">2</span>]) <span class="comment">// "0"</span></span><br></pre></td></tr></table></figure>

<p>定义一个含有 100 个元素的数组 r，最后一个元素被初始化为 - 1，其它元素都是用 0 初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个 slice 类型一般写作 [] T，其中 T 代表 slice 中元素的类型</p>
<p>一个 slice 是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且 slice 的底层确实引用一个数组对象</p>
<p>一个 slice 由三个部分构成：指针、长度和容量</p>
<ul>
<li><p>指针指向第一个 slice 元素对应的底层数组元素的地址，要注意的是 slice 的第一个元素并不一定就是数组的第一个元素</p>
</li>
<li><p>长度对应 slice 中元素的数目。长度不能超过容量，容量一般是从 slice 的开始位置到底层数据的结尾位置</p>
</li>
<li><p>内置的 len 和 cap 函数分别返回 slice 的长度和容量</p>
</li>
</ul>
<hr>
<p>内置的 make 函数创建一个指定元素类型、长度和容量的 slice。容量部分可以省略，在这种情况下，容量将等于长度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></table></figure>

<p>在底层，make 创建了一个匿名的数组变量，然后返回一个 slice；只有通过返回的 slice 才能引用底层匿名的数组变量</p>
<p>在第一种语句中，slice 是整个数组的 view。在第二个语句中，slice 只引用了底层数组的前 len 个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的</p>
<h3 id="append-函数"><a href="#append-函数" class="headerlink" title="append() 函数"></a>append() 函数</h3><p>内置的 append 函数用于向 slice 追加元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runes []<span class="keyword">rune</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello, 世界"</span> &#123;</span><br><span class="line">    runes = <span class="built_in">append</span>(runes, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, runes) <span class="comment">// "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"</span></span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>哈希表是一种巧妙并且实用的数据结构。它是一个无序的 key/value 对的集合，其中所有的 key 都是不同的，然后通过给定的 key 可以在常数时间复杂度内检索、更新或删除对应的 value</p>
<p>其中 K 对应的 key 必须是支持 == 比较运算符的数据类型，所以 map 可以通过测试 key 是否相等来判断是否已经存在</p>
<p><strong>虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做 key 类型则是一个坏的想法，正如第三章提到的，最坏的情况是可能出现的 NaN 和任何浮点数都不相等</strong></p>
<p>内置的 make 函数可以创建一个 map</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// mapping from strings to ints</span></span><br></pre></td></tr></table></figure>

<p>我们也可以用 map 字面值的语法创建 map，同时还可以指定一些最初的 key/value</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"alice"</span>:   <span class="number">31</span>,</span><br><span class="line">    <span class="string">"charlie"</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这相当于</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">ages[<span class="string">"alice"</span>] = <span class="number">31</span></span><br><span class="line">ages[<span class="string">"charlie"</span>] = <span class="number">34</span></span><br></pre></td></tr></table></figure>

<p>使用内置的 delete 函数可以删除元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(ages, <span class="string">"alice"</span>) <span class="comment">// remove element ages["alice"]</span></span><br></pre></td></tr></table></figure>

<p>如果一个查找失败将返回 value 类型对应的零值，例如，即使 map 中不存在 “bob” 下面的代码也可以正常工作，因为 ages [“bob”] 失败时将返回 0</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"bob"</span>] = ages[<span class="string">"bob"</span>] + <span class="number">1</span> <span class="comment">// happy birthday! &lt;-funny</span></span><br></pre></td></tr></table></figure>

<p>而且 <code>x += y</code> 和 <code>x++</code> 等简短赋值语法也可以用在 map 上，所以上面的代码可以改写成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"bob"</span>] += <span class="number">1</span></span><br><span class="line">ages[<span class="string">"bob"</span>]++</span><br></pre></td></tr></table></figure>

<p>Map 的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序</p>
<p>在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同</p>
<hr>
<p>果 key 不存在，那么将得到 value 对应类型的零值</p>
<p>这个规则很实用，但是有时候可能需要知道对应的元素是否真的是在 map 之中</p>
<p>例如，如果元素类型是一个数字，你可能需要区分一个已经存在的 0，和不存在而返回零值的 0，可以像下面这样测试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age, ok := ages[<span class="string">"bob"</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">/* "bob" is not a key in this map; age == 0. */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>你会经常看到将这两个结合起来使用，像这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">"bob"</span>]; !ok &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在这种场景下，map 的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在</p>
<p>布尔变量一般命名为 ok，特别适合马上用于 if 条件判断部分</p>
<hr>
<blockquote>
<p><code>byte</code> 是 <code>uint8</code> 的别称，常用来处理 ascii 字符<br><code>rune</code> 是 <code>int32</code> 的别称，常用来处理 unicode 或 utf-8 字符</p>
</blockquote>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体，每个值称为结构体的成员</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="keyword">int</span></span><br><span class="line">    Name      <span class="keyword">string</span></span><br><span class="line">    Address   <span class="keyword">string</span></span><br><span class="line">    DoB       time.Time</span><br><span class="line">    Position  <span class="keyword">string</span></span><br><span class="line">    Salary    <span class="keyword">int</span></span><br><span class="line">    ManagerID <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dilbert Employee</span><br></pre></td></tr></table></figure>

<p>dilbert 结构体变量的成员可以通过点操作符访问，比如 dilbert.Name 和 dilbert.DoB。因为 dilbert 是一个变量，它所有的成员也同样是变量，我们可以直接对每个成员赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dilbert.Salary -= <span class="number">5000</span> <span class="comment">// demoted, for writing too few lines of code</span></span><br></pre></td></tr></table></figure>

<p>或者是对成员取地址，然后通过指针访问</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">position := &amp;dilbert.Position</span><br><span class="line">*position = <span class="string">"Senior "</span> + *position <span class="comment">// promoted, for outsourcing to Elbonia</span></span><br></pre></td></tr></table></figure>

<h3 id="结构体字面值"><a href="#结构体字面值" class="headerlink" title="结构体字面值"></a>结构体字面值</h3><p>结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">int</span> &#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>第二种写法，以成员名字和相应的值来初始化，可以包含部分或全部的成员</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br></pre></td></tr></table></figure>

<p>在这种形式的结构体字面值写法中，如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要</p>
<p>两种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员</p>
<hr>
<p>结构体可以作为函数的参数和返回值。例如，这个 Scale 函数将 Point 类型的值缩放后返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(p Point, factor <span class="keyword">int</span>)</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Point&#123;p.X * factor, p.Y * factor&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(Scale(Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">5</span>)) <span class="comment">// "&#123;5 10&#125;"</span></span><br></pre></td></tr></table></figure>

<p>结构体可以作为函数的参数和返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(p Point, factor <span class="keyword">int</span>)</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Point&#123;p.X * factor, p.Y * factor&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(Scale(Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">5</span>)) <span class="comment">// "&#123;5 10&#125;"</span></span><br></pre></td></tr></table></figure>

<p>如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bonus</span><span class="params">(e *Employee, percent <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Salary * percent / <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在 Go 语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AwardAnnualRaise</span><span class="params">(e *Employee)</span></span> &#123;</span><br><span class="line">    e.Salary = e.Salary * <span class="number">105</span> / <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为结构体通常通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pp := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>它和下面的语句是等价的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pp := <span class="built_in">new</span>(Point)</span><br><span class="line">*pp = Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h3><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 == 或！= 运算符进行比较。相等比较运算符 == 将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">int</span> &#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) <span class="comment">// "false"</span></span><br><span class="line">fmt.Println(p == q)                   <span class="comment">// "false"</span></span><br></pre></td></tr></table></figure>

<p>可比较的结构体类型和其他可比较的类型一样，可以用于 map 的 key 类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">    hostname <span class="keyword">string</span></span><br><span class="line">    port     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hits := <span class="built_in">make</span>(<span class="keyword">map</span>[address]<span class="keyword">int</span>)</span><br><span class="line">hits[address&#123;<span class="string">"golang.org"</span>, <span class="number">443</span>&#125;]++</span><br></pre></td></tr></table></figure>

<h3 id="结构体嵌入和匿名成员"><a href="#结构体嵌入和匿名成员" class="headerlink" title="结构体嵌入和匿名成员"></a>结构体嵌入和匿名成员</h3><p>Go 语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员</p>
<p>匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针</p>
<p>下面的代码中，Circle 和 Wheel 各自都有一个匿名成员</p>
<p>我们可以说 Point 类型被嵌入到了 Circle 结构体，同时 Circle 类型被嵌入到了 Wheel 结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y, Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle</span><br><span class="line">    Spokes <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span>            <span class="comment">// equivalent to w.Circle.Point.X = 8</span></span><br><span class="line">w.Y = <span class="number">8</span>            <span class="comment">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class="line">w.Radius = <span class="number">5</span>       <span class="comment">// equivalent to w.Circle.Radius = 5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法访问了</p>
<p>其中匿名成员 Circle 和 Point 都有自己的名字 —— 就是命名的类型名字 —— 但是这些名字在点操作符中是可选的</p>
<p>我们在访问子成员的时候可以忽略任何匿名成员部分</p>
<hr>
<p>不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">20</span>&#125;                       <span class="comment">// compile error: unknown fields</span></span><br><span class="line">w = Wheel&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>, Radius: <span class="number">5</span>, Spokes: <span class="number">20</span>&#125; <span class="comment">// compile error: unknown fields</span></span><br></pre></td></tr></table></figure>

<p>结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;Circle&#123;Point&#123;<span class="number">8</span>, <span class="number">8</span>&#125;, <span class="number">5</span>&#125;, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;</span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>, <span class="comment">// <span class="doctag">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>考虑一个应用程序，该程序负责收集各种电影评论并提供反馈功能。它的 Movie 数据类型和一个典型的表示电影的值列表如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title  <span class="keyword">string</span></span><br><span class="line">    Year   <span class="keyword">int</span>  <span class="string">`json:"released"`</span></span><br><span class="line">    Color  <span class="keyword">bool</span> <span class="string">`json:"color,omitempty"`</span></span><br><span class="line">    Actors []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> movies = []Movie&#123;</span><br><span class="line">    &#123;Title: <span class="string">"Casablanca"</span>, Year: <span class="number">1942</span>, Color: <span class="literal">false</span>,</span><br><span class="line">        Actors: []<span class="keyword">string</span>&#123;<span class="string">"Humphrey Bogart"</span>, <span class="string">"Ingrid Bergman"</span>&#125;&#125;,</span><br><span class="line">    &#123;Title: <span class="string">"Cool Hand Luke"</span>, Year: <span class="number">1967</span>, Color: <span class="literal">true</span>,</span><br><span class="line">        Actors: []<span class="keyword">string</span>&#123;<span class="string">"Paul Newman"</span>&#125;&#125;,</span><br><span class="line">    &#123;Title: <span class="string">"Bullitt"</span>, Year: <span class="number">1968</span>, Color: <span class="literal">true</span>,</span><br><span class="line">        Actors: []<span class="keyword">string</span>&#123;<span class="string">"Steve McQueen"</span>, <span class="string">"Jacqueline Bisset"</span>&#125;&#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的数据结构特别适合 JSON 格式，并且在两者之间相互转换也很容易。将一个 Go 语言中类似 movies 的结构体 slice 转为 JSON 的过程叫编组（marshaling）</p>
<p>编组通过调用 json.Marshal 函数完成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data, err := json.Marshal(movies)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Fatalf(<span class="string">"JSON marshaling failed: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="comment">//[&#123;"Title":"Casablanca","Year":1942,"Color":false,"Actors":["Humphrey Bogart","Ingrid Bergman"]&#125;,&#123;"Title":"Cool Hand Luke","Year":1967,"Color":true,"Actors":["Paul Newman"]&#125;,&#123;"Title":"Bullitt","Year":1968,"Color":true,"Actors":["Steve McQueen","Jacqueline Bisset"]&#125;]</span></span><br></pre></td></tr></table></figure>

<p>这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个 json.MarshalIndent 函数将产生整齐缩进的输出</p>
<p><strong>该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data, err := json.MarshalIndent(movies, <span class="string">""</span>, <span class="string">"    "</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"JSON marshaling failed: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, data)</span><br></pre></td></tr></table></figure>

<p>上面的代码将产生这样的输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Title"</span>: <span class="string">"Casablanca"</span>,</span><br><span class="line">        <span class="string">"Year"</span>: <span class="number">1942</span>,</span><br><span class="line">        <span class="string">"Color"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Actors"</span>: [</span><br><span class="line">            <span class="string">"Humphrey Bogart"</span>,</span><br><span class="line">            <span class="string">"Ingrid Bergman"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Title"</span>: <span class="string">"Cool Hand Luke"</span>,</span><br><span class="line">        <span class="string">"Year"</span>: <span class="number">1967</span>,</span><br><span class="line">        <span class="string">"Color"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"Actors"</span>: [</span><br><span class="line">            <span class="string">"Paul Newman"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Title"</span>: <span class="string">"Bullitt"</span>,</span><br><span class="line">        <span class="string">"Year"</span>: <span class="number">1968</span>,</span><br><span class="line">        <span class="string">"Color"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"Actors"</span>: [</span><br><span class="line">            <span class="string">"Steve McQueen"</span>,</span><br><span class="line">            <span class="string">"Jacqueline Bisset"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>许多 web 服务都提供 JSON 接口，通过 HTTP 接口发送 JSON 格式请求并返回 JSON 格式的信息</p>
<h2 id="文本和-HTML-模板"><a href="#文本和-HTML-模板" class="headerlink" title="文本和 HTML 模板"></a>文本和 HTML 模板</h2><p>提供了一个将变量值填充到一个文本或 HTML 格式的模板的机制，提供了一个将变量值填充到一个文本或 HTML 格式的模板的机制</p>
<p>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的 <code></code> 对象</p>
<p>大部分的字符串只是按字面值打印，但是对于 actions 部分将触发其它的行为</p>
<p>每个 actions 都包含了一个用模板语言书写的表达式，一个 action 虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流 if-else 语句和 range 循环语句，还有其它实例化模板等诸多特性</p>
<p>下面是一个简单的模板字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> templ = <span class="string">`&#123;&#123;.TotalCount&#125;&#125; issues:</span></span><br><span class="line"><span class="string">&#123;&#123;range .Items&#125;&#125;----------------------------------------</span></span><br><span class="line"><span class="string">Number: &#123;&#123;.Number&#125;&#125;</span></span><br><span class="line"><span class="string">User:   &#123;&#123;.User.Login&#125;&#125;</span></span><br><span class="line"><span class="string">Title:  &#123;&#123;.Title | printf "%.64s"&#125;&#125;</span></span><br><span class="line"><span class="string">Age:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;`</span></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span> <span class="params">(result-list)</span></span> &#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，返回值列表描述了函数返回值的变量名以及类型</p>
<p>如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的，如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hypot</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hypot(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">// "5"</span></span><br></pre></td></tr></table></figure>

<p>如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面 2 个声明是等价的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i, j, k <span class="keyword">int</span>, s, t <span class="keyword">string</span>)</span></span>                 &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>, j <span class="keyword">int</span>, k <span class="keyword">int</span>,  s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>在 Go 中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得 Go 有别于那些将函数运行失败看作是异常的语言</p>
<p>虽然 Go 有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即 bug，而不是那些在健壮程序中应该被避免的程序错误</p>
<h3 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h3><p>如果 findLinks 对 http.Get 的调用失败，findLinks 会直接将这个 HTTP 错误返回给调用者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对 html.Parse 的调用失败时，findLinks 不会直接返回 html.Parse 的错误，因为缺少两条重要信息：1、发生错误时的解析器（html parser）；2、发生错误的 url</p>
<p>因此，findLinks 构造了一个新的错误信息，既包含了这两项，也包括了底层的解析出错的信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"parsing %s as HTML: %v"</span>, url,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 os 包为例，os 包确保文件操作（如 os.Open、Read、Write、Close）返回的每个错误的描述不仅仅包含错误的原因（如无权限，文件目录不存在）也包含文件名，这样调用者在构造新的错误信息时无需再添加这些信息</p>
<hr>
<p>第二种策略，如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作</p>
<p>在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitForServer</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;    </span><br><span class="line">    <span class="comment">// 设置一分钟的重试deadline</span></span><br><span class="line">   <span class="keyword">const</span> timeout = <span class="number">1</span> * time.Minute</span><br><span class="line">   deadline := time.Now().Add(timeout)</span><br><span class="line">   <span class="keyword">for</span> tries := <span class="number">0</span>; time.Now().Before(deadline); tries++ &#123;</span><br><span class="line">      _, err := http.Head(url)</span><br><span class="line">      <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      log.Printf(<span class="string">"server not responding (%s);retrying..."</span>, err)</span><br><span class="line">      time.Sleep(time.Second &lt;&lt; <span class="keyword">uint</span>(tries))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fmt.Errorf(<span class="string">"server %s failed to respond after %s"</span>, url, timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序</p>
<p>需要注意的是，这种策略只应在 main 中执行</p>
<p>对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了 bug，才能在库函数中结束程序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := WaitForServer(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Fprintf(os.Stderr, <span class="string">"Site is down: %v\n"</span>, err)</span><br><span class="line">	os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 log.Fatalf 可以更简洁的代码达到与上文相同的效果。log 中的所有函数，都默认会在错误信息之前输出时间信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := WaitForServer(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">"Site is down: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过 log 包提供函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"ping failed: %v; networking disabled"</span>,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者标准错误流输出错误信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">"ping failed: %v; networking disabled\n"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>log 包中的所有函数会为没有换行符的字符串增加换行符</p>
<hr>
<p>第五种策略：我们可以直接忽略掉错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dir, err := ioutil.TempDir(<span class="string">""</span>, <span class="string">"scratch"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"failed to create temp dir: %v"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...use temp dir…</span></span><br><span class="line">os.RemoveAll(dir) <span class="comment">// ignore errors; $TMPDIR is cleaned periodically</span></span><br></pre></td></tr></table></figure>

<p>尽管 os.RemoveAll 会失败，但上面的例子并没有做错误处理，这是因为操作系统会定期的清理临时目录</p>
<p>正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响。我们应该在每次函数调用后，都养成考虑错误处理的习惯，当你决定忽略某个错误时，你应该在清晰的记录下你的意图</p>
<p>在 Go 中，错误处理有一套独特的编码风格</p>
<p>检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前</p>
<p>如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在 else 语句块中，而应直接放在函数体中</p>
<p>Go 中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑</p>
<h2 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h2><p>在GO中，函数被看作第一类值</p>
<p>函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">negative</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> -n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">product</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := square</span><br><span class="line">	fmt.Println(f(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">	f = negative</span><br><span class="line">	fmt.Println(f(<span class="number">3</span>))</span><br><span class="line">	fmt.Printf(<span class="string">"%T"</span>, f)</span><br><span class="line"></span><br><span class="line">	f= product</span><br><span class="line">	fmt.Println(f(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数类型的零值是 nil。调用值为 nil 的函数值会引起 panic 错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">f(<span class="number">3</span>) <span class="comment">// 此处f的值为nil, 会引起panic错误</span></span><br></pre></td></tr></table></figure>

<p>函数值可以与 nil 比较</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"> <span class="keyword">if</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">     f(<span class="number">3</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>但是函数值之间是不可比较的，也不能用函数值作为 map 的 key</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值</p>
<p>函数字面量的语法和函数声明相似，区别在于 func 关键字后没有函数名。函数值字面量是一种表达式，它的值被成为匿名函数（anonymous function）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Map(<span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;, <span class="string">"HAL-9000"</span>)</span><br></pre></td></tr></table></figure>

<p>更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// squares返回一个匿名函数。</span></span><br><span class="line"><span class="comment">// 该匿名函数每次被调用时都会返回下一个数的平方。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) <span class="comment">// "1"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "4"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "9"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "16"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 squares 返回另一个类型为 func () int 的函数。对 squares 的一次调用会生成一个局部变量 x 并返回一个匿名函数。每次调用时匿名函数时，该函数都会先使 x 的值加 1，再返回 x 的平方</p>
<p>第二次调用 squares 时，会生成第二个 x 变量，并返回一个新的匿名函数，新匿名函数操作的是第二个 x 变量</p>
<p>squares 的例子证明，函数值不仅仅是一串代码，还记录了状态。在 squares 中定义的匿名内部函数可以访问和更新 squares 中的局部变量，这意味着匿名函数和 squares 中，存在变量引用</p>
<p>这就是函数值属于引用类型和函数值不可比较的原因。Go 使用闭包（closures）技术实现函数值，Go 程序员也把函数值叫做闭包</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>参数数量可变的函数称为为可变参数函数</p>
<p>defer 语句会将函数推迟到外层函数返回之后执行</p>
<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</p>
<p>典型的例子就是 fmt.Printf 和类似函数。Printf 首先接收一个的必备参数，之后接收任意个数的后续参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        total += val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(sum())           <span class="comment">// "0"</span></span><br><span class="line">fmt.Println(sum(<span class="number">3</span>))          <span class="comment">// "3"</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// "10"</span></span><br></pre></td></tr></table></figure>

<h2 id="Deferred-函数"><a href="#Deferred-函数" class="headerlink" title="Deferred 函数"></a>Deferred 函数</h2><p>你只需要在调用普通函数或方法前加上关键字 defer，就完成了 defer 所需要的语法</p>
<p>当 defer 语句被执行时，跟在 defer 后面的函数会被延迟执行</p>
<p>直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。你可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反</p>
<p>并且，当<code>defer</code>声明时，其参数就会被实时解析</p>
<p>所以，确保 title 在所有执行路径下（即使函数运行失败）都关闭了网络连接，可以使用<code>defer</code>进行处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">title</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    ct := resp.Header.Get(<span class="string">"Content-Type"</span>)</span><br><span class="line">    <span class="keyword">if</span> ct != <span class="string">"text/html"</span> &amp;&amp; !strings.HasPrefix(ct,<span class="string">"text/html;"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s has type %s, not text/html"</span>,url, ct)</span><br><span class="line">    &#125;</span><br><span class="line">    doc, err := html.Parse(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"parsing %s as HTML: %v"</span>, url,err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...print doc's title element…</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>对文件的操作，同样可以采用<code>defer</code>机制，比如对文件的操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int64</span> = bytes.MinRead</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fi, err := f.Stat(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> size := fi.Size() + bytes.MinRead; size &gt; n &#123;</span><br><span class="line">			n = size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> readAll(f, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="基于指针对象的方法"><a href="#基于指针对象的方法" class="headerlink" title="基于指针对象的方法"></a>基于指针对象的方法</h2><p>当调用一个函数时，会对其每一个参数值进行拷贝，<strong>如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针</strong>，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span> <span class="title">ScaleBy</span><span class="params">(factor <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">   p.X *= factor</span><br><span class="line">   p.Y *=factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要调用指针类型方法 <code>(*Point).ScaleBy</code>，只要提供一个 Point 类型的指针即可，像下面这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*r) <span class="comment">// "&#123;2, 4&#125;"</span></span><br></pre></td></tr></table></figure>

<p>或者这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">pptr := &amp;p</span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// "&#123;2, 4&#125;"</span></span><br></pre></td></tr></table></figure>

<p>或者这样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">(&amp;p).ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// "&#123;2, 4&#125;"</span></span><br></pre></td></tr></table></figure>

<p>如果接收器 p 是一个 Point 类型的变量，并且其方法需要一个 Point 指针作为接收器，我们可以用下面这种简短的写法</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></table></figure>

<p>编译器会隐式地帮我们用 &amp; p 去调用 ScaleBy 这个方法。这种简写方法只适用于 “变量”，包括 struct 里的字段比如 p.X，以及 array 和 slice 内的元素比如 perim [0]</p>
<ol>
<li>不管你的 method 的 receiver 是指针类型还是非指针类型，都是可以通过指针 / 非指针类型进行调用的，编译器会帮你做类型转换。</li>
<li>在声明一个 method 的 receiver 该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为 receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝，即浅拷贝</li>
</ol>
<h2 id="通过嵌入结构体来扩展类型"><a href="#通过嵌入结构体来扩展类型" class="headerlink" title="通过嵌入结构体来扩展类型"></a>通过嵌入结构体来扩展类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">   geomotry.Point</span><br><span class="line">   Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line">red := color.RGBA&#123;<span class="number">255</span>, <span class="number">0</span> ,<span class="number">0</span> , <span class="number">255</span>&#125;</span><br><span class="line">blue := color.RGBA&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>&#125;</span><br><span class="line"><span class="keyword">var</span> p = ColoredPoint&#123;geomotry.Point&#123;<span class="number">1</span>,<span class="number">1</span>&#125;, red&#125;</span><br><span class="line"><span class="keyword">var</span> q = ColoredPoint&#123;geomotry.Point&#123;<span class="number">5</span>,<span class="number">4</span>&#125;, blue&#125;</span><br><span class="line">fmt.Println(p.Distance(q.Point))</span><br><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br><span class="line">q.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p.Distance(q.Point))</span><br></pre></td></tr></table></figure>

<p>由于ColoredPoint包含一个Point，所以上诉方式与下面的方式等价</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p ColoredPoint)</span> <span class="title">Distance</span><span class="params">(q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.Point.Distance(q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ColoredPoint)</span> <span class="title">ScaleBy</span><span class="params">(factor <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    p.Point.ScaleBy(factor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Point.Distance 被第一个包装方法调用时，它的接收器值是 p.Point，而不是 p，当然了，在 Point 类的方法里，你是访问不到 ColoredPoint 的任何字段的</p>
<hr>
<p>下面是一个小 trick。这个例子展示了简单的 cache，其使用两个包级别的变量来实现，一个 mutex 互斥量 (§9.2) 和它所操作的 cache</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu sync.Mutex <span class="comment">// guards mapping</span></span><br><span class="line">    mapping = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    v := mapping[key]</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个版本在功能上是一致的，但将两个包级别的变量放在了 cache 这个 struct 一组内</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    mapping <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    mapping: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    cache.Lock()</span><br><span class="line">    v := cache.mapping[key]</span><br><span class="line">    cache.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a>方法值和方法表达式</h2><p>我们经常选择一个方法，并且在同一个表达式里执行，比如常见的 p.Distance () 形式，实际上将其分成两步来执行也是可能的</p>
<p>p.Distance 叫作 “选择器”，选择器会返回一个方法 “值”-&gt; 一个将方法 (Point.Distance) 绑定到特定接收器变量的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distanceFormP := p.Distance</span><br><span class="line">fmt.Println(distanceFormP(q))</span><br><span class="line"><span class="keyword">var</span> origin Point</span><br><span class="line">fmt.Println(distanceFormP(origin))</span><br><span class="line">scaleP := p.ScaleBy</span><br><span class="line">scaleP(<span class="number">2</span>)</span><br><span class="line">scaleP(<span class="number">3</span>)</span><br><span class="line">scaleP(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6-5-练习"><a href="#6-5-练习" class="headerlink" title="6.5 练习"></a>6.5 练习</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"bytes"</span></span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123;</span><br><span class="line">   words []<span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Has reports whether the set contains the non-negative value x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Has</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   word, bit := x/<span class="number">64</span>, <span class="keyword">uint</span>(x%<span class="number">64</span>)</span><br><span class="line">   <span class="keyword">return</span> word &lt; <span class="built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="number">1</span>&lt;&lt;bit) != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add adds the non-negative value x to the set.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   word, bit := x/<span class="number">64</span>, <span class="keyword">uint</span>(x%<span class="number">64</span>)</span><br><span class="line">   <span class="keyword">for</span> word &gt;= <span class="built_in">len</span>(s.words) &#123;</span><br><span class="line">      s.words = <span class="built_in">append</span>(s.words, <span class="number">0</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   s.words[word] |= <span class="number">1</span> &lt;&lt; bit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnionWith sets s to the union of s and t.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">UnionWith</span><span class="params">(t *IntSet)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i, tword := <span class="keyword">range</span> t.words &#123;</span><br><span class="line">      <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s.words) &#123;</span><br><span class="line">         s.words[i] |= tword</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         s.words = <span class="built_in">append</span>(s.words, tword)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">IntersectWith</span><span class="params">(t *IntSet)</span></span> &#123;</span><br><span class="line">   temp := <span class="built_in">new</span>(IntSet)</span><br><span class="line">   <span class="keyword">for</span> i, word := <span class="keyword">range</span> t.words &#123;</span><br><span class="line">      <span class="keyword">if</span> word == <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s.Has(<span class="number">64</span>*i+j) &#123;</span><br><span class="line">               temp.Add(<span class="number">64</span>*i+j)</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   s.words = temp.words</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">DifferenceWith</span><span class="params">(t *IntSet)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i, word := <span class="keyword">range</span> s.words &#123;</span><br><span class="line">      <span class="keyword">if</span> word == <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> t.Has(<span class="number">64</span>*i+j) &#123;</span><br><span class="line">               s.Remove(<span class="number">64</span>*i+j)</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span>  <span class="title">SymmetricDifference</span><span class="params">(t *IntSet)</span></span> &#123;</span><br><span class="line">   temp := s.Copy()</span><br><span class="line">   temp.IntersectWith(t)</span><br><span class="line">   s.UnionWith(t)</span><br><span class="line">   s.DifferenceWith(temp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String returns the set as a string of the form "&#123;1 2 3&#125;".</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">   buf.WriteByte(<span class="string">'&#123;'</span>)</span><br><span class="line">   <span class="keyword">for</span> i, word := <span class="keyword">range</span> s.words &#123;</span><br><span class="line">      <span class="keyword">if</span> word == <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> buf.Len() &gt; <span class="built_in">len</span>(<span class="string">"&#123;"</span>) &#123;</span><br><span class="line">               buf.WriteByte(<span class="string">' '</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Fprintf(&amp;buf, <span class="string">"%d"</span>, <span class="number">64</span>*i+j)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   buf.WriteByte(<span class="string">'&#125;'</span>)</span><br><span class="line">   <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the number if elements</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> le <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> _, word := <span class="keyword">range</span> s.words &#123;</span><br><span class="line">      <span class="keyword">if</span> word == <span class="number">0</span>&#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)) != <span class="number">0</span>&#123;</span><br><span class="line">            le++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> le</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove x from the set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Remove</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   word, bit := x/<span class="number">64</span>, <span class="keyword">uint</span>(x%<span class="number">64</span>)</span><br><span class="line">   s.words[word] ^= <span class="number">1</span>&lt;&lt;bit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove all elements from the set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i, word := <span class="keyword">range</span> s.words &#123;</span><br><span class="line">      <span class="keyword">if</span> word == <span class="number">0</span>&#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)) != <span class="number">0</span>&#123;</span><br><span class="line">            s.words[i] ^= <span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return a copy of the set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Copy</span><span class="params">()</span> *<span class="title">IntSet</span></span> &#123;</span><br><span class="line">   res := <span class="built_in">new</span>(IntSet)</span><br><span class="line">   res.words = <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="built_in">len</span>(s.words))</span><br><span class="line">   <span class="keyword">for</span> i, word := <span class="keyword">range</span> s.words &#123;</span><br><span class="line">      <span class="keyword">if</span> word == <span class="number">0</span>&#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)) != <span class="number">0</span>&#123;</span><br><span class="line">            res.words[i] = word | <span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">AddAll</span><span class="params">(nums ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      s.Add(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Elems</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i, word := <span class="keyword">range</span> s.words &#123;</span><br><span class="line">      <span class="keyword">if</span> word == <span class="number">0</span>&#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)) != <span class="number">0</span>&#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="number">64</span>*i+j)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x, y IntSet</span><br><span class="line">   x.AddAll(<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">144</span>)</span><br><span class="line">   fmt.Println(x.String())</span><br><span class="line"></span><br><span class="line">   y.Add(<span class="number">9</span>)</span><br><span class="line">   y.Add(<span class="number">42</span>)</span><br><span class="line">   fmt.Println(y.String())</span><br><span class="line"></span><br><span class="line">   x.SymmetricDifference(&amp;y)</span><br><span class="line">   fmt.Println(x.String())</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, i := <span class="keyword">range</span> x.Elems() &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>Go 语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会</p>
<p>这种限制包内成员的方式同样适用于 struct 或者一个类型的方法</p>
<p>因而如果我们想要封装一个对象，我们必须将其定义为一个 struct</p>
<p>封装的三个优点</p>
<ul>
<li>因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可</li>
<li>隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的 api 情况下能得到更大的自由</li>
<li>第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口约定"><a href="#接口约定" class="headerlink" title="接口约定"></a>接口约定</h2><p>接口类型是一种抽象的类型</p>
<p>它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会展示出它们自己的方法，也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么</p>
<h3 id="练习7-1"><a href="#练习7-1" class="headerlink" title="练习7.1"></a>练习7.1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeCounter</span><span class="params">(p []<span class="keyword">byte</span>, bsf bufio.SplitFunc)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	scanner := bufio.NewScanner(bytes.NewReader(p))</span><br><span class="line">	scanner.Split(bsf)</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		count++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count, scanner.Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *WordsCount)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span>&#123;</span><br><span class="line">	count, err := TypeCounter(p, bufio.ScanWords)</span><br><span class="line">	*c += WordsCount(count)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(p), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *LinesCount)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span>&#123;</span><br><span class="line">	count, err := TypeCounter(p, bufio.ScanLines)</span><br><span class="line">	*c += LinesCount(count)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(p), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习7-2"><a href="#练习7-2" class="headerlink" title="练习7.2"></a>练习7.2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CounterWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	Write io.Writer</span><br><span class="line">	Count <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountingWriter</span><span class="params">(w io.Writer)</span> <span class="params">(io.Writer, *<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">   cw := CounterWriter&#123;</span><br><span class="line">      Write: w,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> cw.Write, &amp;(cw.Count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例</p>
<p>在往下看，我们发现有些新的接口类型通过组合已经有的接口来定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用到的语法和结构内嵌相似，我们可以用这种方式以一个简写命名另一个接口，而不用声明它所有的方法</p>
<p>这种方式本称为接口内嵌</p>
<p>尽管略失简洁，我们可以像下面这样，不使用内嵌来声明 io.Writer 接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者甚至使用种混合的风格</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习7-4-7-5"><a href="#练习7-4-7-5" class="headerlink" title="练习7.4 7.5"></a>练习7.4 7.5</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">   s        []<span class="keyword">string</span></span><br><span class="line">   i        <span class="keyword">int64</span></span><br><span class="line">   prevRune   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LimitedReader <span class="keyword">struct</span> &#123;</span><br><span class="line">   R     io.Reader</span><br><span class="line">   N     <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LimitedReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span><span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> l.N &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>, io.EOF</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">int64</span>(<span class="built_in">len</span>(p)) &gt; l.N &#123;</span><br><span class="line">      p = p[<span class="number">0</span>:l.N]</span><br><span class="line">   &#125;</span><br><span class="line">   n, err = l.R.Read(p)</span><br><span class="line">   l.N -= <span class="keyword">int64</span>(n)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r io.Reader, n <span class="keyword">int64</span>)</span> <span class="title">io</span>.<span class="title">Reader</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;LimitedReader&#123;r, n&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span> &#123; <span class="keyword">return</span> &amp;Reader&#123;findlinks1.Parse(s), <span class="number">0</span>, <span class="number">-1</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h2><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口</p>
<h2 id="sort-interface-接口"><a href="#sort-interface-接口" class="headerlink" title="sort.interface 接口"></a>sort.interface 接口</h2><p>一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是 sort.Interface 的三个方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span> <span class="comment">// i, j are indices of sequence elements</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="error-接口"><a href="#error-接口" class="headerlink" title="error 接口"></a>error 接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个 error 最简单的方法就是调用 errors.New 函数，它会根据传入的错误信息返回一个新的 error</p>
<p>整个 errors 包仅只有 4 行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> &amp;errorString&#123;text&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123; text <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.text &#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言是一个使用在接口值上的操作。语法上它看起来像 x.(T) 被称为断言类型，这里 x 表示一个接口的类型和 T 表示一个类型</p>
<p>一个类型断言检查它操作对象的动态类型是否和断言的类型匹配</p>
<hr>
<p>这里有两种可能</p>
<p>第一种，如果断言的类型 T 是一个具体类型，然后类型断言检查 x 的动态类型是否和 T 相同。如果这个检查成功了，类型断言的结果是 x 的动态值，当然它的类型是 T，换句话说，具体类型的类型断言从它的操作对象中获得具体的值如果检查失败，接下来这个操作会抛出 panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File)      <span class="comment">// success: f == os.Stdout</span></span><br><span class="line">c := w.(*bytes.Buffer) <span class="comment">// panic: interface holds *os.File, not *bytes.Buffer</span></span><br></pre></td></tr></table></figure>

<p>第二种，如果相反断言的类型 T 是一个接口类型，然后类型断言检查是否 x 的动态类型满足 T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型 T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// success: *os.File has both Read and Write</span></span><br><span class="line">w = <span class="built_in">new</span>(ByteCounter)</span><br><span class="line">rw = w.(io.ReadWriter) <span class="comment">// panic: *ByteCounter has no Read method</span></span><br></pre></td></tr></table></figure>

<p>经常地我们对一个接口值的动态类型是不确定的，并且我们更愿意去检验它是否是一些特定的类型。如果类型断言出现在一个预期有两个结果的赋值操作中，例如如下的定义，这个操作不会在失败的时候发生 panic 但是代替地返回一个额外的第二个结果，这个结果是一个标识成功的布尔值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = os.Stdout</span><br><span class="line">f, ok := w.(*os.File)      <span class="comment">// success:  ok, f == os.Stdout</span></span><br><span class="line">b, ok := w.(*bytes.Buffer) <span class="comment">// failure: !ok, b == nil</span></span><br></pre></td></tr></table></figure>

<h2 id="基于类型断言区别错误类型"><a href="#基于类型断言区别错误类型" class="headerlink" title="基于类型断言区别错误类型"></a>基于类型断言区别错误类型</h2><p>I/O 可以因为任何数量的原因失败，但是有三种经常的错误必须进行不同的处理：文件已经存在（对于创建操作），找不到文件（对于读取操作），和权限拒绝。os 包中提供了这三个帮助函数来对给定的错误值表示的失败进行分类：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsExist</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPermission</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>下面这里是它的实际使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, err := os.Open(<span class="string">"/no/such/file"</span>)</span><br><span class="line">fmt.Println(os.IsNotExist(err)) <span class="comment">// "true"</span></span><br></pre></td></tr></table></figure>

<h2 id="类型开关"><a href="#类型开关" class="headerlink" title="类型开关"></a>类型开关</h2><p>接口被以两种不同的方式使用</p>
<p>在第一个方式中，以 io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler，和 error 为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代表的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上</p>
<p>第二个方式利用一个接口值可以持有各种具体类型值的能力并且将这个接口认为是这些类型的 union（联合）。类型断言用来动态地区别这些类型并且对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不是在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为 discriminated unions（可辨识联合</p>
<p>如果你熟悉面向对象编程，你可能会将这两种方式当作是 subtype polymorphism（子类型多态、动态多态）和 ad hoc polymorphism（非参数多态、静态多态）</p>
<h1 id="Goroutines-和-Channels"><a href="#Goroutines-和-Channels" class="headerlink" title="Goroutines 和 Channels"></a>Goroutines 和 Channels</h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>当一个程序启动时，其主函数即在一个单独的 goroutine 中运行，我们叫它 main goroutine。新的 goroutine 会用 go 语句来创建</p>
<p>在语法上，go 语句是一个普通的函数或方法调用前加上关键字 go</p>
<p>go 语句会使其语句中的函数在一个新创建的 goroutine 中运行，而 go 语句本身会迅速地完成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f()    <span class="comment">// call f(); wait for it to return</span></span><br><span class="line"><span class="keyword">go</span> f() <span class="comment">// create a new goroutine that calls f(); don't wait</span></span><br></pre></td></tr></table></figure>

<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>果说<code>goroutine</code> 是 Go 语言程序的并发体的话，那么<code>channels</code> 则是它们之间的通信机制。一个<code>channel</code> 是一个通信机制，它可以让一个 <code>goroutine</code> 通过它给另一个 <code>goroutine</code> 发送值信息</p>
<p>每个 <code>channel</code>都有一个特殊的类型，也就是 <code>channels</code> 可发送数据的类型.例如：一个可以发送 int 类型数据的 channel 一般写为 <code>chan int</code></p>
<p>使用内置的 make 函数，我们可以创建一个 channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch has type 'chan int'</span></span><br></pre></td></tr></table></figure>

<p>和 map 类似，channel 也对应一个 make 创建的底层数据结构的引用</p>
<p>当我们复制一个 channel 或用于函数参数传递时，我们只是拷贝了一个 channel 引用，因此调用者和被调用者将引用同一个 channel 对象</p>
<p>和其它的引用类型一样，channel 的零值也是 nil</p>
<p>两个相同类型的 channel 可以使用 == 运算符比较。如果两个 channel 引用的是相同的对象，那么比较的结果为真。一个 channel 也可以和 nil 进行比较。</p>
<hr>
<p>一个 channel 有发送和接受两个主要操作，都是通信行为</p>
<p>一个发送语句将一个值从一个 goroutine 通过 channel 发送到另一个执行接收操作的 goroutine</p>
<p>发送和接收两个操作都使用 <code>&lt;-</code> 运算符。在发送语句中，<code>&lt;-</code> 运算符分割 channel 和要发送的值</p>
<p>在接收语句中，<code>&lt;-</code> 运算符写在 channel 对象之前。一个不使用接收结果的接收操作也是合法的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// a send statement</span></span><br><span class="line">x = &lt;-ch <span class="comment">// a receive expression in an assignment statement</span></span><br><span class="line">&lt;-ch     <span class="comment">// a receive statement; result is discarded</span></span><br></pre></td></tr></table></figure>

<p>Channel 还支持 close 操作，用于关闭 channel，随后对基于该 channel 的任何发送操作都将导致 panic 异常</p>
<p>对一个已经被 close 过的 channel 进行接收操作依然可以接受到之前已经成功发送的数据；如果 channel 中已经没有数据的话将产生一个零值的数据</p>
<p>使用内置的 close 函数就可以关闭一个 channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>以最简单方式调用 make 函数创建的是一个无缓存的 channel，但是我们也可以指定第二个整型参数，对应 channel 的容量。如果 channel 的容量大于零，那么该 channel 就是带缓存的 channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure>

<h3 id="串联的-channels"><a href="#串联的-channels" class="headerlink" title="串联的 channels"></a>串联的 channels</h3><p>Channels 也可以用于将多个 goroutine 连接在一起，一个 Channel 的输出作为下一个 Channel 的输入。这种串联的 Channels 就是所谓的管道（pipeline）。下面的程序用两个 channels 将三个 goroutine 串联起来，如图 8.1 所示。</p>
<p><img src="http://shouce.jb51.net/gopl-zh/images/ch8-01.png" alt="img"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Counter</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">         naturals &lt;- x</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">close</span>(naturals)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Squares</span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> x := <span class="keyword">range</span> naturals &#123;</span><br><span class="line">         squares &lt;- x * x</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">close</span>(squares)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Printer (in main goroutine)</span></span><br><span class="line">   <span class="keyword">for</span> x := <span class="keyword">range</span> squares &#123;</span><br><span class="line">      fmt.Println(x)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单方向的-Channel"><a href="#单方向的-Channel" class="headerlink" title="单方向的 Channel"></a>单方向的 Channel</h3><p>为了表明这种意图并防止被滥用，Go 语言的类型系统提供了单方向的 channel 类型，分别用于只发送或只接收的 channel。类型 <code>chan&lt;- int</code> 表示一个只发送 int 的 channel，只能发送不能接收。相反，类型 <code>&lt;-chan int</code> 表示一个只接收 int 的 channel，只能接收不能发送。（箭头 <code>&lt;-</code> 和关键字 chan 的相对位置表明了 channel 的方向。）这种限制将在编译期检测。</p>
<p>因为关闭操作只用于断言不再向 channel 发送新的数据，所以只有在发送者所在的 goroutine 才会调用 close 函数，因此对一个只接收的 channel 调用 close 将是一个编译错误。</p>
<p>这是改进的版本，这一次参数使用了单方向 channel 类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">      out &lt;- x</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">      out &lt;- v * v</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">      fmt.Println(v)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   <span class="keyword">go</span> counter(naturals)</span><br><span class="line">   <span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">   printer(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 counter（naturals）时，naturals 的类型将隐式地从 chan int 转换成 chan&lt;- int。调用 printer (squares) 也会导致相似的隐式转换，这一次是转换为 <code>&lt;-chan int</code> 类型只接收型的 channel。任何双向 channel 向单向 channel 变量的赋值操作都将导致该隐式转换。这里并没有反向转换的语法：也就是不能将一个类似 <code>chan&lt;- int</code> 类型的单向型的 channel 转换为 <code>chan int</code> 类型的双向型的 channel</p>
<h3 id="带缓存的-Channels"><a href="#带缓存的-Channels" class="headerlink" title="带缓存的 Channels"></a>带缓存的 Channels</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/04/25/Effective-Go/">Effective Go</a><a class="next" href="/2020/01/14/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/">微机原理笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E6%9C%9F%E7%AD%9B%E9%80%89/">中期筛选</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/12/%E5%89%91%E6%8C%87offer/">剑指offer</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/Effective-Go/">Effective Go</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/15/The-Go-Programming-Language%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">The-Go-Programming-Language 读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/14/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/">微机原理笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/13/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B0/">《汇编语言》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/2020-%E5%B9%B4%E8%AF%BB%E7%9A%84%E4%B9%A6/">2020 年读的书</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《Go 语言笔记》、《Go By Example》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/hello-world/">Hello World</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Amezf's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>