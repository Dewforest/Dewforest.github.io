<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>The-Go-Programming-Language 读书笔记 | Amezf's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">The-Go-Programming-Language 读书笔记</h1><a id="logo" href="/.">Amezf's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 文章</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">The-Go-Programming-Language 读书笔记</h1><div class="post-meta">Jan 15, 2020<span> | </span><span class="category"><a href="/categories/Golang/">Golang</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#程序结构"><span class="toc-number">1.</span> <span class="toc-text">程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#命名"><span class="toc-number">1.1.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#声明"><span class="toc-number">1.2.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-number">1.3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简短变量声明"><span class="toc-number">1.3.1.</span> <span class="toc-text">简短变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指针"><span class="toc-number">1.3.2.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-函数"><span class="toc-number">1.3.3.</span> <span class="toc-text">new 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#赋值"><span class="toc-number">1.4.</span> <span class="toc-text">赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#元组赋值"><span class="toc-number">1.4.1.</span> <span class="toc-text">元组赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可赋值性"><span class="toc-number">1.4.2.</span> <span class="toc-text">可赋值性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型"><span class="toc-number">1.5.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包与文件"><span class="toc-number">1.6.</span> <span class="toc-text">包与文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础数据类型"><span class="toc-number">2.</span> <span class="toc-text">基础数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#整型"><span class="toc-number">2.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浮点数"><span class="toc-number">2.2.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复数"><span class="toc-number">2.3.</span> <span class="toc-text">复数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">2.4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串和-Byte-切片"><span class="toc-number">2.4.1.</span> <span class="toc-text">字符串和 Byte 切片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量"><span class="toc-number">2.5.</span> <span class="toc-text">常量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复合数据类型"><span class="toc-number">3.</span> <span class="toc-text">复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">3.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slice"><span class="toc-number">3.2.</span> <span class="toc-text">Slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#append-函数"><span class="toc-number">3.2.1.</span> <span class="toc-text">append() 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">3.3.</span> <span class="toc-text">Map</span></a></li></ol></li></ol></div></div><div class="post-content"><p>中文译名：《Go 语言圣经》</p>
<p>”Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.“</p>
<a id="more"></a>

<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>在习惯上，Go 语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。因此，在标准库有 QuoteRuneToASCII 和 parseRequestLine 这样的函数命名，但是一般不会用 quote_rune_to_ASCII 和 parse_request_line 这样的命名。而像 ASCII 和 HTML 这样的缩略词则避免使用大小写混合的写法，它们可能被称为 htmlEscape、HTMLEscape 或 escapeHTML，但不会是 escapeHtml</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>Go 语言主要有四种类型的声明语句：var、const、type 和 func</p>
<p>分别对应变量、常量、类型和函数实体对象的声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boilingF = <span class="number">212.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f = boilingF</span><br><span class="line">	<span class="keyword">var</span> c = (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></span><br><span class="line">	fmt.Printf(<span class="string">"boiling point = %g°F or %g°c\n"</span>, f, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>var 声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure>

<p>其中 “<em>类型</em>” 或 “ <em>= 表达式</em>” 两个部分可以省略其中的一个。</p>
<p>如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息</p>
<p>如果初始化表达式被省略，那么将用零值初始化该变量</p>
<p><strong>数值</strong>类型变量对应的零值是 <strong>0</strong></p>
<p><strong>布尔</strong>类型变量对应的零值是 <strong>false</strong></p>
<p><strong>字符串</strong>类型对应的零值是<strong>空字符串</strong></p>
<p><strong>接口或引用</strong>类型（包括 slice、指针、map、chan 和函数）变量对应的零值是 <strong>nil</strong></p>
<p><strong>数组</strong>或<strong>结构体</strong>等聚合类型对应的零值是每个元素或字段都是<strong>对应该类型的零值</strong></p>
<h3 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a>简短变量声明</h3><p>以 <code>名字 := 表达式</code>的形式声明变量，变量的类型根据表达式来自动推导，下面是<code>lissajous</code>函数中的三个简短变量声明语句</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anim := gif.GIF&#123;loopCount: nframes&#125;</span><br><span class="line">freq := rand.Float64() * <span class="number">3.0</span></span><br><span class="line">t := <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p>因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化</p>
<p>var 形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> boiling <span class="keyword">float64</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> names []String</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> p Point</span><br></pre></td></tr></table></figure>

<p>如果有一些已经在相同的词法域声明过了</p>
<p>那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">out, err := os.Create(outfile)</span><br></pre></td></tr></table></figure>

<p>简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f, err := os.Create(outfile) <span class="comment">// compile error: no new variables</span></span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>与C语言指针类似</p>
<p>一个指针的值是另一个变量的地址，一个指针对应变量在内存中的存储位置，并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址</p>
<p>通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x         <span class="comment">// p, of type *int, points to x</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "1"</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// equivalent to x = 2</span></span><br><span class="line">fmt.Println(x)  <span class="comment">// "2"</span></span><br></pre></td></tr></table></figure>

<h3 id="new-函数"><a href="#new-函数" class="headerlink" title="new 函数"></a>new 函数</h3><p>另一个创建变量的方法是调用内建的 new 函数</p>
<p>表达式 new (T) 将创建一个 T 类型的匿名变量，初始化为 T 类型的零值，然后返回变量地址，返回的指针类型为 <code>*T</code></p>
<p><strong>相当于创建了一个只知道地址，却没有名字的临时变量，用指针去读取该值</strong></p>
<p>用 new 创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用 new (T)</p>
<p>换言之，new 函数类似是一种语法糖，而不是一个新的基础概念</p>
<p>每次调用 new 函数都是返回一个新的变量的地址，因此下面两个地址是不同的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">q := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(p == q) <span class="comment">// "false"</span></span><br></pre></td></tr></table></figure>

<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>二元算术运算符和赋值语句的复合操作有一个简洁形式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count[x] *= scale</span><br></pre></td></tr></table></figure>

<h3 id="元组赋值"><a href="#元组赋值" class="headerlink" title="元组赋值"></a>元组赋值</h3><p>元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值</p>
<p>在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x</span><br><span class="line"></span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br></pre></td></tr></table></figure>

<p>GCD算法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h3><p>函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medals := []<span class="keyword">string</span>&#123;<span class="string">"gold"</span>, <span class="string">"silver"</span>, <span class="string">"bronze"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这与下面赋值行为类似</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">medals[<span class="number">0</span>] = <span class="string">"gold"</span></span><br><span class="line">medals[<span class="number">1</span>] = <span class="string">"silver"</span></span><br><span class="line">medals[<span class="number">2</span>] = <span class="string">"bronze"</span></span><br></pre></td></tr></table></figure>

<p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的</p>
<p>可赋值性的规则对于不同类型有着不同要求</p>
<p>对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil 可以赋值给任何指针或引用类型的变量</p>
<p>常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构</p>
<p>新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容</p>
<p><code>type 类型名字 底层类型</code></p>
<p>将<code>float64</code>类型定义为两种不同的温度单位类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	AbsoluteZeroC Celsius = <span class="number">-273.15</span></span><br><span class="line">	FreezingC Celsius = <span class="number">0</span></span><br><span class="line">	BoilingC Celsius = <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span> <span class="title">Fahrenheit</span></span> &#123; <span class="keyword">return</span> Fahrenheit(c * <span class="number">9</span> / <span class="number">5</span> + <span class="number">32</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span> <span class="title">Celsius</span></span> &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>)&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于每一个类型T，都有一个对应的类型转换操作<code>T(x)</code>，用于将x转换为T类型，只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身</strong></p>
<p>比较运算符 <code>==</code> 和 <code>&lt;</code> 也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较</p>
<p>但是如果两个值有着不同的类型，则不能直接进行比较</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c Celsius</span><br><span class="line"><span class="keyword">var</span> f Fahrenheit</span><br><span class="line">fmt.Println(c == <span class="number">0</span>)          <span class="comment">// "true"</span></span><br><span class="line">fmt.Println(f &gt;= <span class="number">0</span>)          <span class="comment">// "true"</span></span><br><span class="line">fmt.Println(c == f)          <span class="comment">// compile error: type mismatch</span></span><br><span class="line">fmt.Println(c == Celsius(f)) <span class="comment">// "true"!</span></span><br></pre></td></tr></table></figure>

<h2 id="包与文件"><a href="#包与文件" class="headerlink" title="包与文件"></a>包与文件</h2><p>Go 语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用</p>
<h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整数之间的相互转换并不会改变数值，它们只是告诉编译器如何解释这个值</p>
<p><strong>但是对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度</strong></p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>Go 语言提供了两种精度的浮点数，<code>float32</code> 和 <code>float64</code></p>
<p>在<code>math</code>包里能查找到浮点数的范围极限值，常量<code>math.MaxFloat32</code>表示<code>float32</code>的最大值，3.4e38</p>
<p>常量<code>math.MaxFloat64</code></p>
<hr>
<p><code>math</code>包中还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：</p>
<p>正无穷大和负无穷大，分别用于表示太大溢出的数字和清零的结果</p>
<p>NaN非数，一般用于表示无效的除法操作结果0/0，sqrt(-1)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">float64</span> <span class="comment">//z = 0</span></span><br><span class="line">fmt.Println(z, -z, <span class="number">1</span>/z, <span class="number">-1</span>/z, z/z) <span class="comment">// 0 -0 +inf -inf NaN</span></span><br></pre></td></tr></table></figure>

<p>可以用<code>math.IsNaN</code>用于测试一个数是否是非数NaN，<code>math.NaN</code>则返回非数对应的值</p>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>Go 语言提供了两种精度的复数类型，<code>complex64</code>和<code>complex128</code>，分别对应<code>float32</code>和<code>float64</code>两种浮点数精度</p>
<p>内置的<code>complex</code>函数用于构建复数，内建的<code>real</code>和<code>imag</code>函数分别返回复数的实部和虚部</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Println(x * y)</span><br><span class="line">fmt.Println(<span class="built_in">real</span>(x * y))</span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(x * y))</span><br></pre></td></tr></table></figure>

<p><strong>练习 3.5：</strong> 实现一个彩色的 Mandelbrot 图像，使用 image.NewRGBA 创建图像，使用 color.RGBA 或 color.YCbCr 生成颜色。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> color.Black </span><br><span class="line"><span class="comment">// -&gt; return color.RGBA&#123;255,182,193,255&#125; 猛男粉</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>内置的<code>len</code>函数可以返回一个字符串中的字节数目，索引操作<code>s[i]</code>返回第i个字节的字节值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello, wolrd"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))		<span class="comment">// "12"</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>], s[<span class="number">7</span>])	<span class="comment">// "104 119" ('h' and 'w')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果试图访问超过字符串索引范围的字节将会导致Panic异常</span></span><br><span class="line"></span><br><span class="line">c := s[<span class="built_in">len</span>(s)] <span class="comment">// panic: index out of range</span></span><br></pre></td></tr></table></figure>

<p>子字符串操作 s [i:j] 基于原始的 s 字符串的第 i 个字节开始到第 j 个字节（并不包含 j 本身）生成一个新字符串，生成的新字符串将包含 j-i 个字节</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s[<span class="number">0</span>:<span class="number">5</span>]) <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure>

<p>不管 i 还是 j 都可能被忽略，当它们被忽略时将采用 0 作为开始位置，采用 len (s) 作为结束的位置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s[:<span class="number">5</span>]) <span class="comment">// "hello"</span></span><br><span class="line">fmt.Println(s[<span class="number">7</span>:]) <span class="comment">// "world"</span></span><br><span class="line">fmt.Println(s[:])  <span class="comment">// "hello, world"</span></span><br></pre></td></tr></table></figure>

<p>其中 + 操作符将两个字符串连接构造一个新字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"goodbye"</span> + s[<span class="number">5</span>:]) <span class="comment">// "goodbye, world"</span></span><br></pre></td></tr></table></figure>

<p>字符串可以用 == 和 &lt; 进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序</p>
<p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值</p>
<p>可以像下面这样将一个字符串追加到另一个字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"left foot"</span></span><br><span class="line">t := s</span><br><span class="line">s += <span class="string">", right foot"</span></span><br></pre></td></tr></table></figure>

<p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="string">'L'</span> <span class="comment">// compile error: cannot assign to s[0]</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串和-Byte-切片"><a href="#字符串和-Byte-切片" class="headerlink" title="字符串和 Byte 切片"></a>字符串和 Byte 切片</h3><p><code>bytes</code>包和<code>strings</code>包同时提供了许多实用函数</p>
<p><code>strings</code>包的六个函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p><code>bytes</code>包对应的六个函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(b, subslice []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(s [][]<span class="keyword">byte</span>, sep []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>无类型常量</strong></p>
<p>在Go语言中许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算（至少有 256bit 的运算精度）</p>
<p>这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串</p>
<p><code>math.Pi</code>无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float32</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span> = math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span> = math.Pi</span><br></pre></td></tr></table></figure>

<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成因为数组的长度是固定的，因此在 Go 语言中很少直接使用数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ar a [<span class="number">3</span>]<span class="keyword">int</span>             <span class="comment">// array of 3 integers</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>])        <span class="comment">// print the first element</span></span><br><span class="line">fmt.Println(a[<span class="built_in">len</span>(a)<span class="number">-1</span>]) <span class="comment">// print the last element, a[2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the indices and elements.</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d %d\n"</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the elements only.</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是 0。我们也可以使用数组字面值语法用一组值来初始化数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">2</span>]) <span class="comment">// "0"</span></span><br></pre></td></tr></table></figure>

<p>定义一个含有 100 个元素的数组 r，最后一个元素被初始化为 - 1，其它元素都是用 0 初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个 slice 类型一般写作 [] T，其中 T 代表 slice 中元素的类型</p>
<p>一个 slice 是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且 slice 的底层确实引用一个数组对象</p>
<p>一个 slice 由三个部分构成：指针、长度和容量</p>
<ul>
<li><p>指针指向第一个 slice 元素对应的底层数组元素的地址，要注意的是 slice 的第一个元素并不一定就是数组的第一个元素</p>
</li>
<li><p>长度对应 slice 中元素的数目。长度不能超过容量，容量一般是从 slice 的开始位置到底层数据的结尾位置</p>
</li>
<li><p>内置的 len 和 cap 函数分别返回 slice 的长度和容量</p>
</li>
</ul>
<hr>
<p>内置的 make 函数创建一个指定元素类型、长度和容量的 slice。容量部分可以省略，在这种情况下，容量将等于长度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></table></figure>

<p>在底层，make 创建了一个匿名的数组变量，然后返回一个 slice；只有通过返回的 slice 才能引用底层匿名的数组变量</p>
<p>在第一种语句中，slice 是整个数组的 view。在第二个语句中，slice 只引用了底层数组的前 len 个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的</p>
<h3 id="append-函数"><a href="#append-函数" class="headerlink" title="append() 函数"></a>append() 函数</h3><p>内置的 append 函数用于向 slice 追加元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runes []<span class="keyword">rune</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello, 世界"</span> &#123;</span><br><span class="line">    runes = <span class="built_in">append</span>(runes, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, runes) <span class="comment">// "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"</span></span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>哈希表是一种巧妙并且实用的数据结构。它是一个无序的 key/value 对的集合，其中所有的 key 都是不同的，然后通过给定的 key 可以在常数时间复杂度内检索、更新或删除对应的 value</p>
<p>其中 K 对应的 key 必须是支持 == 比较运算符的数据类型，所以 map 可以通过测试 key 是否相等来判断是否已经存在</p>
<p><strong>虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做 key 类型则是一个坏的想法，正如第三章提到的，最坏的情况是可能出现的 NaN 和任何浮点数都不相等</strong></p>
<p>内置的 make 函数可以创建一个 map</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// mapping from strings to ints</span></span><br></pre></td></tr></table></figure>

<p>我们也可以用 map 字面值的语法创建 map，同时还可以指定一些最初的 key/value</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"alice"</span>:   <span class="number">31</span>,</span><br><span class="line">    <span class="string">"charlie"</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这相当于</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">ages[<span class="string">"alice"</span>] = <span class="number">31</span></span><br><span class="line">ages[<span class="string">"charlie"</span>] = <span class="number">34</span></span><br></pre></td></tr></table></figure>

<p>使用内置的 delete 函数可以删除元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(ages, <span class="string">"alice"</span>) <span class="comment">// remove element ages["alice"]</span></span><br></pre></td></tr></table></figure>

<p>如果一个查找失败将返回 value 类型对应的零值，例如，即使 map 中不存在 “bob” 下面的代码也可以正常工作，因为 ages [“bob”] 失败时将返回 0</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"bob"</span>] = ages[<span class="string">"bob"</span>] + <span class="number">1</span> <span class="comment">// happy birthday! &lt;-funny</span></span><br></pre></td></tr></table></figure>

<p>而且 <code>x += y</code> 和 <code>x++</code> 等简短赋值语法也可以用在 map 上，所以上面的代码可以改写成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"bob"</span>] += <span class="number">1</span></span><br><span class="line">ages[<span class="string">"bob"</span>]++</span><br></pre></td></tr></table></figure>

<p>Map 的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序</p>
<p>在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同</p>
<hr>
<p>果 key 不存在，那么将得到 value 对应类型的零值</p>
<p>这个规则很实用，但是有时候可能需要知道对应的元素是否真的是在 map 之中</p>
<p>例如，如果元素类型是一个数字，你可能需要区分一个已经存在的 0，和不存在而返回零值的 0，可以像下面这样测试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age, ok := ages[<span class="string">"bob"</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">/* "bob" is not a key in this map; age == 0. */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>你会经常看到将这两个结合起来使用，像这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">"bob"</span>]; !ok &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在这种场景下，map 的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在</p>
<p>布尔变量一般命名为 ok，特别适合马上用于 if 条件判断部分</p>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2020/01/14/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/">微机原理笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E6%9C%9F%E7%AD%9B%E9%80%89/">中期筛选</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/15/The-Go-Programming-Language%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">The-Go-Programming-Language 读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/14/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/">微机原理笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/13/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B0/">《汇编语言》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/42--%E6%8E%A5%E9%9B%A8%E6%B0%B4/">Leetcode-cn 42 接雨水</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/2020-%E5%B9%B4%E8%AF%BB%E7%9A%84%E4%B9%A6/">2020 年读的书</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《Go 语言笔记》、《Go By Example》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/Leetcode-cn-695--%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/">Leetcode-cn 695 岛屿中的最大面积</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/Leetcode-cn-329--%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/">Leetcode-cn 329 岛屿中的最长递增路径</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/Leetcode-cn-200--%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">Leetcode-cn 200 岛屿数量</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Amezf's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>