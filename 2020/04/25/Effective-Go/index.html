<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Effective Go | Amezf's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Effective Go</h1><a id="logo" href="/.">Amezf's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 文章</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Effective Go</h1><div class="post-meta">Apr 25, 2020<span> | </span><span class="category"><a href="/categories/Golang/">Golang</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#命名规则"><span class="toc-number">1.</span> <span class="toc-text">命名规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#包名"><span class="toc-number">1.1.</span> <span class="toc-text">包名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取器"><span class="toc-number">1.2.</span> <span class="toc-text">获取器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口命名"><span class="toc-number">1.3.</span> <span class="toc-text">接口命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#驼峰命名"><span class="toc-number">1.4.</span> <span class="toc-text">驼峰命名</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分号"><span class="toc-number">2.</span> <span class="toc-text">分号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#控制结构"><span class="toc-number">3.</span> <span class="toc-text">控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#重新声明与再次赋值"><span class="toc-number">3.1.</span> <span class="toc-text">重新声明与再次赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for"><span class="toc-number">3.2.</span> <span class="toc-text">for</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch"><span class="toc-number">3.3.</span> <span class="toc-text">switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型选择"><span class="toc-number">3.4.</span> <span class="toc-text">类型选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多值返回"><span class="toc-number">4.1.</span> <span class="toc-text">多值返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可命名结果形参"><span class="toc-number">4.2.</span> <span class="toc-text">可命名结果形参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Defer"><span class="toc-number">4.3.</span> <span class="toc-text">Defer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据"><span class="toc-number">5.</span> <span class="toc-text">数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#new-分配"><span class="toc-number">5.1.</span> <span class="toc-text">new 分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数与复合字面"><span class="toc-number">5.2.</span> <span class="toc-text">构造函数与复合字面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#make-分配"><span class="toc-number">5.3.</span> <span class="toc-text">make 分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">5.4.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切片"><span class="toc-number">5.5.</span> <span class="toc-text">切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二维切片"><span class="toc-number">5.6.</span> <span class="toc-text">二维切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#映射"><span class="toc-number">5.7.</span> <span class="toc-text">映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#append-函数"><span class="toc-number">5.8.</span> <span class="toc-text">append() 函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化"><span class="toc-number">6.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#init-函数"><span class="toc-number">6.0.1.</span> <span class="toc-text">init 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法"><span class="toc-number">7.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#指针方法-vs-值方法"><span class="toc-number">7.1.</span> <span class="toc-text">指针方法 vs. 值方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接口与其他类型"><span class="toc-number">8.</span> <span class="toc-text">接口与其他类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口转换与类型断言"><span class="toc-number">8.1.</span> <span class="toc-text">接口转换与类型断言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#空白标识符"><span class="toc-number">9.</span> <span class="toc-text">空白标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多重赋值中的空白标识符"><span class="toc-number">9.1.</span> <span class="toc-text">多重赋值中的空白标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口检查"><span class="toc-number">9.2.</span> <span class="toc-text">接口检查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发"><span class="toc-number">10.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通过通信共享内存"><span class="toc-number">10.1.</span> <span class="toc-text">通过通信共享内存</span></a></li></ol></li></ol></div></div><div class="post-content"><p>Effective Go为如何编写清晰、地道的 Go 代码提供了一些技巧</p>
<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>正如命名在其它语言中的地位，它在 Go 中同样重要。有时它们甚至会影响语义： 例如，某个名称在包外是否可见，就取决于其首个字符是否为大写字母</p>
<h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p>当一个包被导入后，包名就会成了内容的访问器。在以下代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"bytes"</span></span><br></pre></td></tr></table></figure>

<p>之后，被导入的包就能通过 <code>bytes.Buffer</code> 来引用了</p>
<p>若所有人都以相同的名称来引用其内容将大有裨益， 这也就意味着包应当有个恰当的名称：其名称应该简洁明了而易于理解</p>
<p>按照惯例， <strong>包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法</strong></p>
<hr>
<p>另一个约定就是包名应为其源码目录的基本名称。在 <code>src/pkg/encoding/base64</code>中的包应作为<code>&quot;encoding/base64&quot;</code>导入，其包名应为<code>base64</code>， 而非<code>encoding_base64</code> 或 <code>encodingBase64</code></p>
<h2 id="获取器"><a href="#获取器" class="headerlink" title="获取器"></a>获取器</h2><p>Go 并不对获取器（getter）和设置器（setter）提供自动支持</p>
<p>若你有个名为 <code>owner</code> （小写，未导出）的字段，其获取器应当名为 <code>Owner</code>（大写，可导出）而非 <code>GetOwner</code></p>
<p>大写字母即为可导出的这种规定为区分方法和字段提供了便利， 若要提供设置器方法，<code>SetOwner</code> 是个不错的选择</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">owner := obj.Owner()</span><br><span class="line"><span class="keyword">if</span> owner != user &#123;</span><br><span class="line">    obj.SetOwner(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口命名"><a href="#接口命名" class="headerlink" title="接口命名"></a>接口命名</h2><p>按照约定，只包含一个方法的接口应当以该方法的名称加上 <code>- er</code> 后缀来命名，如 <code>Reader</code>、<code>Writer</code>、 <code>Formatter</code>、<code>CloseNotifier</code>等</p>
<p><code>Read</code>、<code>Write</code>、<code>Close</code>、<code>Flush</code>、 <code>String</code> 等都具有典型的签名和意义，为避免冲突，请不要用这些名称为你的方法命名， 除非你明确知道它们的签名和意义相同</p>
<p>反之，若你的类型实现了的方法， 与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名。 请将字符串转换方法命名为 <code>String</code> 而非 <code>ToString</code></p>
<h2 id="驼峰命名"><a href="#驼峰命名" class="headerlink" title="驼峰命名"></a>驼峰命名</h2><p>最后，Go 中的约定是使用 <code>MixedCaps</code> 或 <code>mixedCaps</code> 而不是下划线来编写多个单词组成的命名。</p>
<h1 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h1><p>和 C 一样，Go 的正式语法使用分号来结束语句；和 C 不同的是，这些分号并不在源码中出现</p>
<p> 取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此因此源码中基本就不用分号了</p>
<p>规则是这样的：若在新行前的最后一个标记为标识符（包括 <code>int</code> 和 <code>float64</code> 这类的单词）、数值或字符串常量之类的基本字面或以下标记之一    </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> <span class="keyword">continue</span> <span class="keyword">fallthrough</span> <span class="keyword">return</span> ++ -- ) &#125;</span><br></pre></td></tr></table></figure>

<p>则词法分析将始终在该标记后面插入分号，这点可以概括为： “如果新行前的标记为语句的末尾，则插入分号”</p>
<p>分号也可在闭括号之前直接省略，因此像</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; dst &lt;- &lt;-src &#125; &#125;()</span><br></pre></td></tr></table></figure>

<p>这样的语句无需分号。通常 Go 程序只在诸如 <code>for</code> 循环子句这样的地方使用分号， 以此来将初始化器、条件及增量元素分开</p>
<p>如果你在一行中写多个语句，也需要用分号隔开</p>
<hr>
<p>警告：无论如何，你都不应将一个控制结构（<code>if</code>、<code>for</code>、<code>switch</code> 或 <code>select</code>）的左大括号放在下一行。如果这样做，就会在大括号前面插入一个分号，这可能引起不需要的效果。 你应该这样写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; f() &#123;</span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而不是这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; f()  <span class="comment">// 错！</span></span><br><span class="line">&#123;           <span class="comment">// 错！</span></span><br><span class="line">	g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><p>Go 中的结构控制与 C 有许多相似之处，但其不同之处才是独到之处</p>
<p> Go 不再使用 <code>do</code> 或 <code>while</code> 循环，只有一个更通用的 <code>for</code></p>
<p><code>switch</code> 要更灵活一点</p>
<p><code>if</code> 和 <code>switch</code> 像 <code>for</code> 一样可接受可选的初始化语句</p>
<p> 此外，还有一个包含类型选择和多路通信复用器的新控制结构：<code>select</code>， 其语法也有些许不同：没有圆括号，而其主体必须始终使用大括号括住</p>
<p>在 Go 中，一个简单的 <code>if</code> 语句看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强制的大括号促使你将简单的 <code>if</code> 语句分成多行。特别是在主体中包含 <code>return</code> 或 <code>break</code> 等控制语句时，这种编码风格的好处一比便知。</p>
<p><strong>由于 <code>if</code> 和 <code>switch</code> 可接受初始化语句， 因此用它们来设置局部变量十分常见</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Print(err)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Go 的库中，你会发现若 <code>if</code> 语句不会执行到下一条语句时，亦即其执行体 以 <code>break</code>、<code>continue</code>、<code>goto</code> 或 <code>return</code> 结束时，不必要的 <code>else</code> 会被省略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">codeUsing(f)</span><br></pre></td></tr></table></figure>

<h2 id="重新声明与再次赋值"><a href="#重新声明与再次赋值" class="headerlink" title="重新声明与再次赋值"></a>重新声明与再次赋值</h2><p>在满足下列条件时，已被声明的变量 <code>v</code> 可出现在<code>:=</code> 声明中：</p>
<ul>
<li>本次声明与已声明的 <code>v</code> 处于同一作用域中（若 <code>v</code> 已在外层作用域中声明过，则此次声明会创建一个新的变量 §），</li>
<li>在初始化中与其类型相应的值才能赋予 <code>v</code></li>
<li>在此次声明中至少另有一个变量是新声明的。</li>
</ul>
<p>这个特性简直就是纯粹的实用主义体现，它使得我们可以很方面地只使用一个 <code>err</code> 值，例如，在一个相当长的 <code>if-else</code> 语句链中， 你会发现它用得很频繁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">d, err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	f.Close()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">codeUsing(f, d)</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go 的 <code>for</code> 循环类似于 C，但却不尽相同。它统一了 <code>for</code> 和 <code>while</code>，不再有 <code>do-while</code> 了。它有三种形式，但只有一种需要分号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如同C的for循环</span></span><br><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如同C的while循环</span></span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如同C的for(;;)循环</span></span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>若你想遍历数组、切片、字符串或者映射，或从信道中读取消息， <code>range</code> 子句能够帮你轻松实现循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">	newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若你只需要该遍历中的第一个项（键或下标），去掉第二个就行了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">if</span> key.expired() &#123;</span><br><span class="line">		<span class="built_in">delete</span>(m, key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若你只需要该遍历中的第二个项（值），请使用<strong>空白标识符</strong>，即下划线来丢弃第一个值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">	sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于字符串，<code>range</code> 能够提供更多便利。它能通过解析 UTF-8， 将每个独立的 Unicode 码点分离出来。错误的编码将占用一个字节，并以符文 U+FFFD 来代替。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> <span class="string">"日本\x80語"</span> &#123; <span class="comment">// \x80 是个非法的UTF-8编码</span></span><br><span class="line">	fmt.Printf(<span class="string">"字符 %#U 始于字节位置 %d\n"</span>, char, pos)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将打印</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符 U+<span class="number">65E5</span> <span class="string">'日'</span> 始于字节位置 <span class="number">0</span></span><br><span class="line">字符 U+<span class="number">672</span>C <span class="string">'本'</span> 始于字节位置 <span class="number">3</span></span><br><span class="line">字符 U+FFFD <span class="string">'�'</span> 始于字节位置 <span class="number">6</span></span><br><span class="line">字符 U+<span class="number">8</span>A9E <span class="string">'語'</span> 始于字节位置 <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>最后，Go 没有逗号操作符，而 <code>++</code> 和 <code>--</code> 为语句而非表达式。 因此，若你想要在 <code>for</code> 中使用多个变量，应采用平行赋值的方式 （因为它会拒绝 <code>++</code> 和 <code>--</code>）.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转 a</span></span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j-go1 &#123;</span><br><span class="line">	a[i], a[j] = a[j], a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>switch</code> 并不会自动下溯，但 <code>case</code> 可通过逗号分隔来列举相同的处理条件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldEscape</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> c &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">' '</span>, <span class="string">'?'</span>, <span class="string">'&amp;'</span>, <span class="string">'='</span>, <span class="string">'#'</span>, <span class="string">'+'</span>, <span class="string">'%'</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管它们在 Go 中的用法和其它类 C 语言差不多，但 <code>break</code> 语句可以使 <code>switch</code> 提前终止。不仅是 <code>switch</code>， 有时候也必须打破层层的循环。在 Go 中，我们只需将标签放置到循环外，然后 “蹦” 到那里即可。下面的例子展示了二者的用法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Loop:</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="built_in">len</span>(src); n += size &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> src[n] &lt; sizeOne:</span><br><span class="line">			<span class="keyword">if</span> validateOnly &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			size = <span class="number">1</span></span><br><span class="line">			update(src[n])</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> src[n] &lt; sizeTwo:</span><br><span class="line">			<span class="keyword">if</span> n+<span class="number">1</span> &gt;= <span class="built_in">len</span>(src) &#123;</span><br><span class="line">				err = errShortInput</span><br><span class="line">                <span class="comment">// 中止当前的for循环，跳到loop语句</span></span><br><span class="line">				<span class="keyword">break</span> Loop</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> validateOnly &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			size = <span class="number">2</span></span><br><span class="line">			update(src[n] + src[n+<span class="number">1</span>]&lt;&lt;shift)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h2><p><code>switch</code> 也可用于判断接口变量的动态类型</p>
<p>如 <strong>类型选择</strong> 通过圆括号中的关键字 <code>type</code> 使用类型断言语法，若 <code>switch</code> 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Printf(<span class="string">"unexpected type %T"</span>, t)       <span class="comment">// %T 输出 t 是什么类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">	fmt.Printf(<span class="string">"boolean %t\n"</span>, t)             <span class="comment">// t 是 bool 类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">	fmt.Printf(<span class="string">"integer %d\n"</span>, t)             <span class="comment">// t 是 int 类型</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">bool</span>:</span><br><span class="line">	fmt.Printf(<span class="string">"pointer to boolean %t\n"</span>, *t) <span class="comment">// t 是 *bool 类型</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">int</span>:</span><br><span class="line">	fmt.Printf(<span class="string">"pointer to integer %d\n"</span>, *t) <span class="comment">// t 是 *int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h2><p>Go 与众不同的特性之一就是函数和方法可返回多个值。这种形式可以改善 C 中一些笨拙的习惯： 将错误值返回（例如用 <code>-1</code> 表示 <code>EOF</code>）和修改通过地址传入的实参</p>
<p>我们可以采用一种简单的方法，来避免为模拟引用参数而传入指针。 以下简单的函数可从字节数组中的特定位置获取其值，并返回该数值和下一个位置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="keyword">byte</span>, i <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(b) &amp;&amp; !isDigit(b[i]); i++ &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	x := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(b) &amp;&amp; isDigit(b[i]); i++ &#123;</span><br><span class="line">		x = x*<span class="number">10</span> + <span class="keyword">int</span>(b[i]) - <span class="string">'0'</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x, i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可命名结果形参"><a href="#可命名结果形参" class="headerlink" title="可命名结果形参"></a>可命名结果形参</h2><p>Go 函数的返回值或结果 “形参” 可被命名，并作为常规变量使用，就像传入的形参一样。 命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值； 若该函数执行了一条不带实参的 <code>return</code> 语句，则结果形参的当前值将被返回。</p>
<p>此名称不是强制性的，但它们能使代码更加简短清晰：它们就是文档。若我们命名了 <code>nextInt</code> 的结果，那么它返回的 <code>int</code> 就值如其意了</p>
<p><code>func nextInt(b []byte, pos int) (value, nextPos int)</code></p>
<p>由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。 下面的 <code>io.ReadFull</code> 就是个很好的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nr <span class="keyword">int</span></span><br><span class="line">		nr, err = r.Read(buf)</span><br><span class="line">		n += nr</span><br><span class="line">		buf = buf[nr:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p>Go 的 <code>defer</code> 语句用于预设一个函数调用（即<strong>推迟执行</strong>函数）， 该函数会在执行 <code>defer</code> 的函数返回之前立即执行</p>
<p>它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数</p>
<p> 典型的例子就是解锁互斥和关闭文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Contents 将文件的内容作为字符串返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contents</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()  <span class="comment">// f.Close 会在我们结束后运行。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result []<span class="keyword">byte</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := f.Read(buf[<span class="number">0</span>:])</span><br><span class="line">		result = <span class="built_in">append</span>(result, buf[<span class="number">0</span>:n]...) <span class="comment">// append 将在后面讨论。</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>, err  <span class="comment">// 我们在这里返回后，f 就会被关闭。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(result), <span class="literal">nil</span> <span class="comment">// 我们在这里返回后，f 就会被关闭。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推迟诸如 <code>Close</code> 之类的函数调用有两点好处：</p>
<p>第一， 它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时， 这种情况往往就会发生。</p>
<p>第二，它意味着 “关闭” 离 “打开” 很近， 这总比将它放在函数结尾处要清晰明了</p>
<p>被推迟函数的实参（如果该函数为方法则还包括接收者）在<strong>推迟</strong>执行时就会求值， 而不是在<strong>调用</strong>执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="new-分配"><a href="#new-分配" class="headerlink" title="new 分配"></a>new 分配</h2><p>Go 提供了两种分配原语，即内建函数 <code>new</code> 和 <code>make</code></p>
<p><code>new</code>是个用来分配内存的内建函数， 但与其它语言中的同名函数不同，它不会<strong>初始化</strong>内存，只会将内存<strong>置零</strong>。 也就是说，<code>new(T)</code> 会为类型为 <code>T</code> 的新项分配已置零的内存空间， 并返回它的地址，也就是一个类型为 <code>*T</code> 的值。用 Go 的术语来说，它返回一个指针， 该指针指向新分配的，类型为 <code>T</code> 的零值。</p>
<p>既然 <code>new</code> 返回的内存已置零，那么当你设计数据结构时， 每种类型的零值就不必进一步初始化了，这意味着该数据结构的使用者只需用 <code>new</code> 创建一个新的对象就能正常工作。例如，<code>bytes.Buffer</code> 的文档中提到 “零值的 <code>Buffer</code> 就是已准备就绪的缓冲区。” 同样，<code>sync.Mutex</code> 并没有显式的构造函数或 <code>Init</code> 方法， 而是零值的 <code>sync.Mutex</code> 就已经被定义为已解锁的互斥锁了。</p>
<p>“零值属性” 可以带来各种好处。考虑以下类型声明。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock    sync.Mutex</span><br><span class="line">	buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SyncedBuffer</code> 类型的值也是在声明时就分配好内存就绪了。后续代码中， <code>p</code> 和 <code>v</code> 无需进一步处理即可正确工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br><span class="line"><span class="keyword">var</span> v SyncedBuffer      <span class="comment">// type  SyncedBuffer</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数与复合字面"><a href="#构造函数与复合字面" class="headerlink" title="构造函数与复合字面"></a>构造函数与复合字面</h2><p>有时零值还不够好，这时就需要一个初始化构造函数，如来自 <code>os</code> 包中的这段代码所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	f := <span class="built_in">new</span>(File)</span><br><span class="line">	f.fd = fd</span><br><span class="line">	f.name = name</span><br><span class="line">	f.dirinfo = <span class="literal">nil</span></span><br><span class="line">	f.nepipe = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里显得代码过于冗长。我们可通过<strong>复合字面</strong>来简化它， 该表达式在每次求值时都会创建新的实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，返回一个局部变量的地址完全没有问题，这点与 C 不同。该局部变量对应的数据 在函数返回后依然有效。实际上，每当获取一个复合字面的地址时，都将为一个新的实例分配内存， 因此我们可以将上面的最后两行代码合并：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;<span class="keyword">File</span>&#123;fd, <span class="keyword">name</span>, nil, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>复合字面的字段必须按顺序全部列出。但如果以 <strong>字段</strong><code>:</code><strong>值</strong> 对的形式明确地标出元素，初始化字段时就可以按任何顺序出现，未给出的字段值将赋予零值。 因此，我们可以用如下形式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">return</span> &amp;<span class="selector-tag">File</span>&#123;<span class="attribute">fd</span>: fd, name: name&#125;</span><br></pre></td></tr></table></figure>

<h2 id="make-分配"><a href="#make-分配" class="headerlink" title="make 分配"></a>make 分配</h2><p>再回到内存分配上来。内建函数 <code>make(T,</code><em>args``</em><code>)</code> 的目的不同于 <code>new(T)</code>。它只用于创建切片、映射和信道，并返回类型为 <code>T</code>（而非 <code>*T</code>）的一个<strong>已初始化</strong> （而非<strong>置零</strong>）的值。 出现这种用差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。 例如，切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量， 在这三项被初始化之前，该切片为 <code>nil</code>。对于切片、映射和信道，<code>make</code> 用于初始化其内部的数据结构并准备好将要使用的值。例如，</p>
<p><code>make([]int, 10, 100)</code></p>
<p>下面的例子阐明了 <code>new</code> 和 <code>make</code> 之间的区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)       <span class="comment">// 分配切片结构；*p == nil；基本没用</span></span><br><span class="line"><span class="keyword">var</span> v  []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>) <span class="comment">// 切片 v 现在引用了一个具有 100 个 int 元素的新数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没必要的复杂：</span></span><br><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line">*p = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 习惯用法：</span></span><br><span class="line">v := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>请记住，<code>make</code> 只适用于映射、切片和信道且不返回指针。若要获得明确的指针， 请使用 <code>new</code> 分配内存。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在详细规划内存布局时，数组是非常有用的，有时还能避免过多的内存分配， 但它们主要用作切片的构件</p>
<p>以下为数组在 Go 和 C 中的主要区别。在 Go 中，</p>
<ul>
<li>数组是值。将一个数组赋予另一个数组会复制其所有元素。</li>
<li>特别地，若将某个数组传入某个函数，它将接收到该数组的一份<strong>副本</strong>而非指针。</li>
<li>数组的大小是其类型的一部分。类型 <code>[10]int</code> 和 <code>[20]int</code> 是不同的。</li>
</ul>
<p>数组为值的属性很有用，但代价高昂；若你想要 C 那样的行为和效率，你可以传递一个指向该数组的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a *[3]<span class="keyword">float64</span>)</span> <span class="params">(sum <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> *a &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array := [...]<span class="keyword">float64</span>&#123;<span class="number">7.0</span>, <span class="number">8.5</span>, <span class="number">9.1</span>&#125;</span><br><span class="line">x := Sum(&amp;array)  <span class="comment">// 注意显式的取址操作</span></span><br></pre></td></tr></table></figure>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。 除了矩阵变换这类需要明确维度的情况外，Go 中的大部分数组编程都是通过切片来完成的。</p>
<p>切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。 若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见， 这可以理解为传递了底层数组的指针。因此，<code>Read</code> 函数可接受一个切片实参 而非一个指针和一个计数；切片的长度决定了可读取数据的上限。以下为 <code>os</code> 包中 <code>File</code> 类型的 <code>Read</code> 方法签名:</p>
<p><code>func (file *File) Read(buf []byte) (n int, err error)</code></p>
<p>该方法返回读取的字节数和一个错误值（若有的话）。若要从更大的缓冲区 <code>b</code> 中读取前 32 个字节，只需对其进行<strong>切片</strong>即可。</p>
<p><code>n, err := f.Read(buf[0:32])</code></p>
<p>只要切片不超出底层数组的限制，它的长度就是可变的，只需将它赋予其自身的切片即可。 切片的<strong>容量</strong>可通过内建函数 <code>cap</code> 获得，它将给出该切片可取得的最大长度。 以下是将数据追加到切片的函数。若数据超出其容量，则会重新分配该切片。返回值即为所得的切片。 该函数中所使用的 <code>len</code> 和 <code>cap</code> 在应用于 <code>nil</code> 切片时是合法的，它会返回 0.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Append</span><span class="params">(slice, data[]<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(slice)</span><br><span class="line">	<span class="keyword">if</span> l + <span class="built_in">len</span>(data) &gt; <span class="built_in">cap</span>(slice) &#123;  <span class="comment">// 重新分配</span></span><br><span class="line">		<span class="comment">// 为了后面的增长，需分配两份。</span></span><br><span class="line">		newSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, (l+<span class="built_in">len</span>(data))*<span class="number">2</span>)</span><br><span class="line">		<span class="comment">// copy 函数是预声明的，且可用于任何切片类型。</span></span><br><span class="line">		<span class="built_in">copy</span>(newSlice, slice)</span><br><span class="line">		slice = newSlice</span><br><span class="line">	&#125;</span><br><span class="line">	slice = slice[<span class="number">0</span>:l+<span class="built_in">len</span>(data)]</span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> data &#123;</span><br><span class="line">		slice[l+i] = c</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维切片"><a href="#二维切片" class="headerlink" title="二维切片"></a>二维切片</h2><p>Go 的数组和切片都是一维的。要创建等价的二维数组或切片，就必须定义一个数组的数组， 或切片的切片，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transform [<span class="number">3</span>][<span class="number">3</span>]<span class="keyword">float64</span>  <span class="comment">// 一个 3x3 的数组，其实是包含多个数组的一个数组。</span></span><br><span class="line"><span class="keyword">type</span> LinesOfText [][]<span class="keyword">byte</span>     <span class="comment">// 包含多个字节切片的一个切片。</span></span><br></pre></td></tr></table></figure>

<p>由于切片长度是可变的，因此其内部可能拥有多个不同长度的切片。在我们的 <code>LinesOfText</code> 例子中，这是种常见的情况：每行都有其自己的长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text := LinesOfText&#123;</span><br><span class="line">	[]<span class="keyword">byte</span>(<span class="string">"Now is the time"</span>),</span><br><span class="line">	[]<span class="keyword">byte</span>(<span class="string">"for all good gophers"</span>),</span><br><span class="line">	[]<span class="keyword">byte</span>(<span class="string">"to bring some fun to the party."</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时必须分配一个二维数组，例如在处理像素的扫描行时，这种情况就会发生。 我们有两种方式来达到这个目的。一种就是独立地分配每一个切片；而另一种就是只分配一个数组， 将各个切片都指向它。采用哪种方式取决于你的应用。若切片会增长或收缩， 就应该通过独立分配来避免覆盖下一行；若不会，用单次分配来构造对象会更加高效。 以下是这两种方法的大概代码，仅供参考。首先是一次一行的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配顶层切片。</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize) <span class="comment">// 每 y 个单元一行。</span></span><br><span class="line"><span class="comment">// 遍历行，为每一行都分配切片</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">	picture[i] = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在是一次分配，对行进行切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配顶层切片，和前面一样。</span></span><br><span class="line">picture := <span class="built_in">make</span>([][]<span class="keyword">uint8</span>, YSize) <span class="comment">// 每 y 个单元一行。</span></span><br><span class="line"><span class="comment">// 分配一个大的切片来保存所有像素</span></span><br><span class="line">pixels := <span class="built_in">make</span>([]<span class="keyword">uint8</span>, XSize*YSize) <span class="comment">// 拥有类型 []uint8，尽管图片是 [][]uint8.</span></span><br><span class="line"><span class="comment">// 遍历行，从剩余像素切片的前面切出每行来。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> picture &#123;</span><br><span class="line">	picture[i], pixels = pixels[:XSize], pixels[XSize:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。 切片不能用作映射键，因为它们的相等性还未定义。与切片一样，映射也是引用类型。 若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。</p>
<p>映射可使用一般的复合字面语法进行构建，其键 - 值对使用逗号分隔，因此可在初始化时很容易地构建它们。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeZone = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	<span class="string">"UTC"</span>:  <span class="number">0</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">"EST"</span>: <span class="number">-5</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">"CST"</span>: <span class="number">-6</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">"MST"</span>: <span class="number">-7</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">	<span class="string">"PST"</span>: <span class="number">-8</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋值和获取映射值的语法类似于数组，不同的是映射的索引不必为整数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset := timeZone[<span class="string">"EST"</span>]</span><br></pre></td></tr></table></figure>

<p>若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值。 例如，若某个映射包含整数，当查找一个不存在的键时会返回 <code>0</code>。 集合可实现成一个值类型为 <code>bool</code> 的映射。将该映射中的项置为 <code>true</code> 可将该值放入集合中，此后通过简单的索引操作即可判断是否存在。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">attended := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">	<span class="string">"Ann"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="string">"Joe"</span>: <span class="literal">true</span>,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attended[person] &#123; <span class="comment">// 若某人不在此映射中，则为 false</span></span><br><span class="line">	fmt.Println(person, <span class="string">"正在开会"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时你需要区分某项是不存在还是其值为零值。如对于一个值本应为零的 <code>&quot;UTC&quot;</code> 条目，也可能是由于不存在该项而得到零值。你可以使用多重赋值的形式来分辨这种情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> seconds <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">seconds, ok = timeZone[tz]</span><br></pre></td></tr></table></figure>

<p>显然，我们可称之为 “逗号 ok” 惯用法。在下面的例子中，若 <code>tz</code> 存在， <code>seconds</code> 就会被赋予适当的值，且 <code>ok</code> 会被置为 <code>true</code>； 若不存在，<code>seconds</code> 则会被置为零，而 <code>ok</code> 会被置为 <code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(tz <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> seconds, ok := timeZone[tz]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> seconds</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">"unknown time zone:"</span>, tz)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若仅需判断映射中是否存在某项而不关心实际的值，可使用<a href="https://go-zh.org/doc/effective_go.html#空白" target="_blank" rel="noopener">空白标识符</a> （<code>_</code>）来代替该值的一般变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure>

<p>要删除映射中的某项，可使用内建函数 <code>delete</code>，它以映射及要被删除的键为实参。 即便对应的键不在该映射中，此操作也是安全的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(timeZone, <span class="string">"PDT"</span>)  <span class="comment">// 现在用标准时间</span></span><br></pre></td></tr></table></figure>

<h2 id="append-函数"><a href="#append-函数" class="headerlink" title="append() 函数"></a>append() 函数</h2><p>现在我们要对内建函数 <code>append</code> 的设计进行补充说明。<code>append</code> 函数的签名不同于前面我们自定义的 <code>Append</code> 函数。大致来说，它就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []T, 元素 ...T)</span> []<span class="title">T</span></span></span><br></pre></td></tr></table></figure>

<p>其中的 <em>T</em> 为任意给定类型的占位符。实际上，你无法在 Go 中编写一个类型 <code>T</code> 由调用者决定的函数。这也就是为何 <code>append</code> 为内建函数的原因：它需要编译器的支持</p>
<p>但如果我们要像 <code>Append</code> 那样将一个切片追加到另一个切片中呢？ 很简单：在调用的地方使用 <code>...</code>，就像我们在上面调用 <code>Output</code> 那样。以下代码片段的输出与上一个相同。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="built_in">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="built_in">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = append(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>

<p>如果没有 <code>...</code>，它就会由于类型错误而无法编译，因为 <code>y</code> 不是 <code>int</code> 类型的</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><h3 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a><code>init</code> 函数</h3><p>最后，每个源文件都可以通过定义自己的无参数 <code>init</code> 函数来设置一些必要的状态。 （其实每个文件都可以拥有多个 <code>init</code> 函数。）而它的结束就意味着初始化结束： 只有该包中的所有变量声明都通过它们的初始化器求值后 <code>init</code> 才会被调用， 而那些 <code>init</code> 只有在所有已导入的包都被初始化后才会被求值。</p>
<p>除了那些不能被表示成声明的初始化外，<code>init</code> 函数还常被用在程序真正开始执行前，检验或校正程序的状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> user == <span class="string">""</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"$USER not set"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> home == <span class="string">""</span> &#123;</span><br><span class="line">		home = <span class="string">"/home/"</span> + user</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gopath == <span class="string">""</span> &#123;</span><br><span class="line">		gopath = home + <span class="string">"/go"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// gopath 可通过命令行中的 --gopath 标记覆盖掉。</span></span><br><span class="line">	flag.StringVar(&amp;gopath, <span class="string">"gopath"</span>, gopath, <span class="string">"override default GOPATH"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="指针方法-vs-值方法"><a href="#指针方法-vs-值方法" class="headerlink" title="指针方法 vs. 值方法"></a>指针方法 vs. 值方法</h2><p>正如 <code>ByteSize</code> 那样，我们可以为任何已命名的类型（除了指针或接口）定义方法； 接收者可不必为结构体。</p>
<p>在之前讨论切片时，我们编写了一个 <code>Append</code> 函数。 我们也可将其定义为切片的方法。为此，我们首先要声明一个已命名的类型来绑定该方法， 然后使该方法的接收者成为该类型的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSlice []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(slice ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 主体和前面相同。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仍然需要该方法返回更新后的切片。为了消除这种不便，我们可通过重新定义该方法， 将一个指向 <code>ByteSlice</code> 的<strong>指针</strong>作为该方法的接收者， 这样该方法就能重写调用者提供的切片了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span> <span class="title">Append</span><span class="params">(data []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	slice := *p</span><br><span class="line">	<span class="comment">// 主体和前面相同，但没有 return。</span></span><br><span class="line">	*p = slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我们做得更好。若我们将函数修改为与标准 <code>Write</code> 类似的方法，就像这样，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ByteSlice)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	slice := *p</span><br><span class="line">	<span class="comment">// 依旧和前面相同。</span></span><br><span class="line">	*p = slice</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(data), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么类型 <code>*ByteSlice</code> 就满足了标准的 <code>io.Writer</code> 接口，这将非常实用。 例如，我们可以通过打印将内容写入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b ByteSlice</span><br></pre></td></tr></table></figure>

<h1 id="接口与其他类型"><a href="#接口与其他类型" class="headerlink" title="接口与其他类型"></a>接口与其他类型</h1><h2 id="接口转换与类型断言"><a href="#接口转换与类型断言" class="headerlink" title="接口转换与类型断言"></a>接口转换与类型断言</h2><p><a href="https://go-zh.org/doc/effective_go.html#类型选择" target="_blank" rel="noopener">类型选择</a>是类型转换的一种形式：它接受一个接口，在选择 （<code>switch</code>）中根据其判断选择对应的情况（<code>case</code>）， 并在某种意义上将其转换为该种类型。以下代码为 <code>fmt.Printf</code> 通过类型选择将值转换为字符串的简化版。若它已经为字符串，我们需要该接口中实际的字符串值； 若它有 <code>String</code> 方法，我们则需要调用该方法所得的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 调用者提供的值。</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种情况获取具体的值，第二种将该接口转换为另一个接口。这种方式对于混合类型来说非常完美</p>
<hr>
<p>若我们只关心一种类型呢？若我们知道该值拥有一个 <code>string</code> 而想要提取它呢？ 只需一种情况的类型选择就行，但它需要<strong>类型断言</strong>。类型断言接受一个接口值， 并从中提取指定的明确类型的值。其语法借鉴自类型选择开头的子句，但它需要一个明确的类型， 而非 <code>type</code> 关键字：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value.(typeName)</span><br></pre></td></tr></table></figure>

<p>而其结果则是拥有静态类型 <code>typeName</code> 的新值。该类型必须为该接口所拥有的具体类型， 或者该值可转换成的第二种接口类型。要提取我们知道在该值中的字符串，可以这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str := value.(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>

<p>但若它所转换的值中不包含字符串，该程序就会以运行时错误崩溃。为避免这种情况， 需使用 “逗号，ok” 惯用测试它能安全地判断该值是否为字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str, ok := value.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"字符串值为 %q\n"</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"该值非字符串\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若类型断言失败，<code>str</code> 将继续存在且为字符串类型，但它将拥有零值，即空字符串。</p>
<p>作为对能量的说明，这里有个 <code>if-else</code> 语句，它等价于本节开头的类型选择。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> str, ok := value.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> str, ok := value.(Stringer); ok &#123;</span><br><span class="line">	<span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h1><h2 id="多重赋值中的空白标识符"><a href="#多重赋值中的空白标识符" class="headerlink" title="多重赋值中的空白标识符"></a>多重赋值中的空白标识符</h2><p><code>for range</code> 循环中对空表标识符的用法是一种具体情况，更一般的情况即为多重赋值。</p>
<p>若某次赋值需要匹配多个左值，但其中某个变量不会被程序使用， 那么用空白标识符来代替该变量可避免创建无用的变量，并能清楚地表明该值将被丢弃。 例如，当调用某个函数时，它会返回一个值和一个错误，但只有错误很重要， 那么可使用空白标识符来丢弃无关的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s does not exist\n"</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>你偶尔会看见为忽略错误而丢弃错误值的代码，这是种糟糕的实践。请务必检查错误返回， 它们会提供错误的理由</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 烂代码！若路径不存在，它就会崩溃。</span></span><br><span class="line">fi, _ := os.Stat(path)</span><br><span class="line"><span class="keyword">if</span> fi.IsDir() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%s is a directory\n"</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h2><p>就像我们在前面<a href="https://go-zh.org/doc/effective_go.html#接口与类型" target="_blank" rel="noopener">接口</a>中讨论的那样， 一个类型无需显式地声明它实现了某个接口。取而代之，该类型只要实现了某个接口的方法， 其实就实现了该接口。在实践中，大部分接口转换都是静态的，因此会在编译时检测。 例如，将一个 <code>*os.File</code> 传入一个预期的 <code>io.Reader</code> 函数将不会被编译， 除非 <code>*os.File</code> 实现了 <code>io.Reader</code> 接口。</p>
<p>尽管有些接口检查会在运行时进行。<code>encoding/json</code> 包中就有个实例它定义了一个 <code>Marshaler</code> 接口。当 JSON 编码器接收到一个实现了该接口的值，那么该编码器就会调用该值的编组方法， 将其转换为 JSON，而非进行标准的类型转换。 编码器在运行时通过<a href="https://go-zh.org/doc/effective_go.html#接口转换" target="_blank" rel="noopener">类型断言</a>检查其属性，就像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m, ok := val.(json.Marshaler)</span><br></pre></td></tr></table></figure>

<p>若只需要判断某个类型是否是实现了某个接口，而不需要实际使用接口本身 （可能是错误检查部分），就使用空白标识符来忽略类型断言的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := val.(json.Marshaler); ok &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"vagolue %v of type %T implements json.Marshaler\n"</span>, val, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要确保某个包中实现的类型一定满足该接口时，就会遇到这种情况。 若某个类型（例如 <code>json.RawMessage</code>） 需要一种定制的 JSON 表现时，它应当实现 <code>json.Marshaler</code>， 不过现在没有静态转换可以让编译器去自动验证它。若该类型通过忽略转换失败来满足该接口， 那么 JSON 编码器仍可工作，但它却不会使用定制的实现。为确保其实现正确， 可在该包中用空白标识符声明一个全局变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ json.Marshaler = (*RawMessage)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>在此声明中，我们调用了一个 <code>*RawMessage</code> 转换并将其赋予了 <code>Marshaler</code>，以此来要求 <code>*RawMessage</code> 实现 <code>Marshaler</code>，这时其属性就会在编译时被检测。 若 <code>json.Marshaler</code> 接口被更改，此包将无法通过编译， 而我们则会注意到它需要更新。</p>
<p>在这种结构中出现空白标识符，即表示该声明的存在只是为了类型检查。 不过请不要为满足接口就将它用于任何类型。作为约定， 仅当代码中不存在静态类型转换时才能这种声明，毕竟这是种罕见的情况。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="通过通信共享内存"><a href="#通过通信共享内存" class="headerlink" title="通过通信共享内存"></a>通过通信共享内存</h2><p>在并发编程中，为实现对共享变量的正确访问需要精确的控制，这在多数环境下都很困难。 Go 语言另辟蹊径，它将共享的值通过信道传递，实际上，多个独立执行的线程从不会主动共享。 在任意给定的时间点，只有一个 Go 程能够访问该值。数据竞争从设计上就被杜绝了。 为了提倡这种思考方式，我们将它简化为一句口号：</p>
<blockquote>
<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>
</blockquote>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/05/12/%E5%89%91%E6%8C%87offer/">剑指offer</a><a class="next" href="/2020/01/15/The-Go-Programming-Language%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">The-Go-Programming-Language 读书笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Golang/">Golang</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E6%9C%9F%E7%AD%9B%E9%80%89/">中期筛选</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/12/%E5%89%91%E6%8C%87offer/">剑指offer</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/Effective-Go/">Effective Go</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/15/The-Go-Programming-Language%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">The-Go-Programming-Language 读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/14/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/">微机原理笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/13/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%94%E8%AE%B0/">《汇编语言》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/2020-%E5%B9%B4%E8%AF%BB%E7%9A%84%E4%B9%A6/">2020 年读的书</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《Go 语言笔记》、《Go By Example》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/hello-world/">Hello World</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Amezf's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>